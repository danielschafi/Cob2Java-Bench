{
  "cobol_file": {
    "file_name": "successful_snippet_712bbc74.cob",
    "content": "       >>SOURCE FORMAT IS FIXED\n      *> ***************************************************************\n      *><* =======================\n      *><* OpenCOBOL SQLite engine\n      *><* =======================\n      *><*\n      *><* .. sidebar: Table of Contents\n      *><*\n      *><*     .. contents: :local:\n      *><*\n      *><* :Author:    Brian Tiffin\n      *><* :Date:      09-Oct-2008\n      *><* :Version:   0.90 based on SQLite 3.5.9\n      *><* :Rights:    Copyright (c) 2008, Brian Tiffin\n      *><*             Licensed under the GNU Public License 2.0\n      *><*             ocsqlite.c is in the public domain in keeping\n      *><*             with the original SQLite source code\n      *><*             This Usage documentation licensed FDL\n      *><* :Purpose:   Demonstrate SQLite in OpenCOBOL\n      *><* :Needs:     libsqlite3-dev and sqlite3 packages\n      *><*             or libsqlite and sqlite version 2 packages\n      *><* :Tectonics: cobc -c ocsqlite.c\n      *><*             cobc -x -lsqlite3 sqlscreen.cob ocsqlite.o\n      *><* :Docgen:    $ ./ocdoc sqlscreen.cob sqlscreen.rst\n      *><+  sqlscreen.html ocfaq.css\n      *><*\n      *><* ----\n      *><* Demo\n      *><* ----\n      *><* sqlscreen.cob demonstrates some of the features provided\n      *><* by the SQLite shell interface.\n      *><*\n      *><* ---------\n      *><* Tectonics\n      *><* ---------\n      *><* Requires sqlite3 and libsqlite3-dev packages (for Debian)\n      *><* Requires OC1.1 packaged on or later than Oct 13th 2008::\n      *><*\n      *><*   $ cobc -c ocshell.c\n      *><*   -or-\n      *><*   $ cobc -c -DSQLITE_OMIT_LOAD_EXTENSION ocshell.c\n      *><*\n      *><*   $ cobc -x -lsqlite3 sqlcaller.cob ocshell.o\n      *><*   -or-\n      *><*   $ cobc -x -lsqlite3 -fdebugging-line sqlcaller.cob\n      *><+  ocshell.o\n      *><*\n      *><* -------------\n      *><* Meta Commands\n      *><* -------------\n      *><* All of the meta (dot) commands supported by the **sqlite3>**\n      *><* console are included in the ocsqlite.c interface.\n      *><*\n      *><* A query of *.help* will list the allowed meta commands.\n      *><*\n      *><* ::\n      *><*\n      *><*   Many of the meta commands output results to stdout.\n      *><*\n      *><*   A few of the commands can be dangerous, and may be\n      *><*   disabled in the 1.0 release.  Commands such as .bail on\n      *><*\n      *><* ---\n      *><* SQL\n      *><* ---\n      *><* SQLite includes nearly all SQL verbs and most database\n      *><* management commands.  Full details can be found at\n      *><* http://www.sqlite.org/lang.html\n      *><*\n      *><*\n      *><* -----------------\n      *><* Source code notes\n      *><* -----------------\n      *><*\n      *> ***************************************************************\n       identification division.\n       program-id. sqlscreen.\n\n       data division.\n       working-storage section.\n       01 name-length          constant 20.\n       01 value-length         constant 132.\n\n      *><* The database name is passed as a zero terminated C string::\n      *><*\n      *><[\n       01 database             pic x(8) value 'test.db' & x'00'.\n      *><]\n       01 db                   usage pointer.\n       01 callback-proc        usage procedure-pointer.\n       01 errstr               pic x(80).\n       01 result               pic s9(9).\n\n       01 query                pic x(255).\n       01 zquery               pic x(256).\n\n       01 main-record.\n          03 key-field         pic 9(10).\n          03 str-field         pic x(20).\n          03 date-field        pic x(20).\n\n       01 sql-table            external.\n          03 sql-records       pic x(50) occurs 20 times.\n\n       01 row-counter          usage binary-long external.\n       01 row-max              usage binary-long.\n\n       screen section.\n       01 entry-screen.\n          05 foreground-color 0 background-color 7 blank screen.\n          05 foreground-color 0 background-color 7\n             line 1 col 14 pic x(20) value \"select * from trial;\".\n          05 foreground-color 0 background-color 7\n             line 2 col 4 pic x(8) value \"Key:\".\n          05 foreground-color 0 background-color 7\n             line 2 col 14 pic x(10) using key-field.\n          05 foreground-color 0 background-color 7\n             line 3 col 4 pic x(8) value \"String:\".\n          05 foreground-color 0 background-color 7\n             line 3 col 14 pic x(20) from str-field.\n          05 foreground-color 0 background-color 7\n             line 4 col 4 pic x(8) value \"Date:\".\n          05 foreground-color 0 background-color 7\n             line 4 col 14 pic x(20) from date-field.\n          05 foreground-color 0 background-color 7\n             line 6 col 4 pic x(17) value \"Hit ENTER to page\".\n\n      *> ***************************************************************\n       procedure division.\n\n      *><*\n      *><* The initialization is somewhat misleading.  The db pointer\n      *><* is set, but the internal ocshell.c database pointer is used\n      *><* on all the queries::\n      *><*\n      *><[\n       call \"ocsqlite_init\" using\n               db\n               database\n               by reference errstr\n               by value function length(errstr)\n           returning result\n       end-call\n       if result not equal zero\n           display \"Result: \" result end-display\n       end-if\n      *><]\n      *><*\n      *><* SQLite uses a callback for each row of a query::\n      *><*\n      *><[\n       set callback-proc to entry \"callback\"\n      *><]\n      *><*\n      *><* And a lot of code only executes if sqlscreen.cob is\n      *><* compiled with -fdebugging-line::\n      *><*\n      *><[\n    >>Dmove \".echo on\" to query\n    >>Dperform ocsql-exec\n\n    >>Dmove \".help\" to query\n    >>Dperform ocsql-exec\n\n    >>Dmove \".tables\" to query\n    >>Dperform ocsql-exec\n\n    >>Dmove \".timer on\" to query\n    >>Dperform ocsql-exec\n\n    >>Dmove \".mode tcl\" to query\n    >>Dperform ocsql-exec\n\n    >>Dmove 0 to row-counter\n    >>Dmove \"select * from trial;\" to query\n    >>Dperform ocsql-exec\n\n    >>Dmove \".mode html\" to query\n    >>Dperform ocsql-exec\n\n    >>Dmove 'insert into trial values (null, \"string\", \"2008-10-10\");'\n    >>D  to query\n    >>Dperform ocsql-exec\n\n    >>Dmove \"select * from thisfails;\" to query\n    >>Dperform ocsql-exec\n\n       move \"drop table trial;\" to query\n       perform ocsql-exec\n\n       move \"create table trial (first integer primary key, \" &\n           \"second char(20), third date);\" to query\n       perform ocsql-exec\n\n    >>Dmove \"pragma count_changes=1;\"  to query\n    >>Dperform ocsql-exec\n\n    >>Dmove \"pragma database_list;\"  to query\n    >>Dperform ocsql-exec\n\n    >>Dmove \".schema trial\" to query\n    >>Dperform ocsql-exec\n\n       move 'insert into trial (first, second, third) values ' &\n           '(null, lower(hex(randomblob(20))), datetime()); ' &\n           'insert into trial values (null, \"something\",' &\n           ' julianday());' to query\n       perform ocsql-exec\n\n    >>Dmove \"select * from trial;\" to query\n    >>Dperform ocsql-exec\n\n    >>Dmove \"pragma count_changes=0;\"  to query\n    >>Dperform ocsql-exec\n      *><[\n      *><*\n      *><* Most of the default demo is here::\n      *><*\n      *><[\n       move 'insert into trial (first, second, third) values ' &\n           '(null, lower(hex(randomblob(20))), datetime()); ' &\n           'insert into trial values (null, \"something\",' &\n           ' julianday());' to query\n       perform ocsql-exec\n      *><]\n      *><*\n      *><* The *.mode column* and *.width* meta statements are\n      *><* critical for this example.  The sqlite shell will now return\n      *><* fixed length fields. Breaking DRY, the widths must be\n      *><* explicitly set.\n      *><*\n      *><* A *.mode csv* could be used with an unstring for variable\n      *><* length datums, but then quotes will need processing as well.\n      *><*\n      *><* ::\n      *><*\n      *><[\n       move \".mode column\" to query\n       perform ocsql-exec\n\n       move \".width 10 20 20\" to query\n       perform ocsql-exec\n\n       move 1 to row-counter\n       move \"select * from trial;\" to query\n       perform ocsql-exec\n       display function trim(sql-table trailing) end-display\n\n       subtract 1 from row-counter giving row-max end-subtract\n       perform varying row-counter from row-max by -1\n           until row-counter < 1\n               move sql-records(row-counter) to main-record\n               display \"|\" key-field \"|\" end-display\n               display \"|\" str-field \"|\" end-display\n               display \"|\" date-field \"|\" end-display\n       end-perform\n      *><]\n      *><*\n      *><* Finally put up a screen, cycling through the records::\n      *><*\n      *><[\n       perform varying row-counter from 1 by 1\n           until row-counter > row-max\n           move sql-records(row-counter) to main-record\n           accept entry-screen end-accept\n       end-perform\n      *><]\n       goback.\n\n      *><*\n      *><* Once again, the alpha release of ocshell.c keeps its own\n      *><* database handle. That will change.  The close call\n      *><* is still necessary, just that the db handle is not used.::\n      *><*\n      *><[\n       call \"ocsqlite_close\"\n           using\n               by value db\n           returning result\n       end-call\n\n       move result to return-code\n       goback.\n      *><]\n      *><*\n\n      *> ***************************************************************\n       ocsql-exec.\n       move spaces to zquery\n       string\n           function trim(query trailing) delimited by size\n           x\"00\" delimited by size\n           into zquery\n       end-string\n      *> set callback-proc to entry \"callback\"\n       call \"ocsqlite\"\n           using by value db\n               callback-proc\n               by reference zquery\n               by value function length(zquery)\n               by reference errstr\n               by value function length(errstr)\n           returning result\n       end-call\n       if result not equal 0\n           display \"Err:    \" errstr end-display\n       end-if\n       .\n\n       end program sqlscreen.\n      *> ***************************************************************\n\n      *> ***************************************************************\n      *><*\n      *><* --------\n      *><* Callback\n      *><* --------\n      *><* Callback procedure.  In sqlite_exec, the callback is passed::\n      *><*\n      *><*   void *user_data, int fields, char **columns, char **names\n      *><*\n      *><* for each row, with the name and value data in separate\n      *><+ arrays.\n      *><*\n      *><* The OpenCOBOL callback procedure is called with::\n      *><*\n      *><*   pointer, int fields, row as alphanum, row length\n      *><*\n      *><* Each line of row data is formatted according to the shell's\n      *><* *mode* setting.  The expectation is .mode column\n      *><+  with fixed .width\n      *> ***************************************************************\n       identification division.\n       program-id. callback.\n\n       data division.\n       working-storage section.\n       01 count-display        pic z9.\n       01 index-display        pic z9.\n\n       01 value-display        pic x(132).\n\n       01 main-record.\n          03 field-1           pic 9(10).\n          03 field-2           pic x(20).\n          03 field-3           pic x(20).\n          03 filler            pic x(82).\n\n       01 row-counter          usage binary-long external.\n\n       01 sql-table            external.\n          03 sql-records       pic x(50) occurs 20 times.\n\n       linkage section.\n       01 nada                 usage pointer.\n       01 field-count          usage binary-long.\n       01 row-data             pic x(132).\n       01 row-length           usage binary-long.\n\n      *> ***************************************************************\n       procedure division using\n           nada field-count row-data row-length.\n\n      *> add zero to field-count giving count-display\n      *> display count-display \" fields\" end-display\n       move spaces to value-display\n       string\n           row-data delimited by low-value\n           into value-display\n       end-string\n       inspect value-display replacing all x\"0a\" by space\n\n      *><*\n      *><* In a demonstration of very bad form; if the external value\n      *><* of row-counter is larger than 0, fill the external\n      *><* sql-records structure::\n      *><*\n      *><[\n       move value-display to main-record\n       if row-counter > 0\n           move main-record to sql-records(row-counter)\n           add 1 to row-counter end-add\n       end-if\n      *><]\n      *><*\n      *><*\n      *><* Cheers\n    >>Ddisplay \"[\"\n    >>D    function trim(main-record trailing)\n    >>D\"]\" end-display\n\n       move 0 to return-code\n       goback.\n\n       end program callback.\n"
  },
  "input_files": [],
  "output_files": [],
  "input_output_files": [],
  "sysin_file": {
    "file_name": "sysin.txt",
    "content": "00001SMITH     JOHN      A 1234567890123456789012345678901234567890\n00002JOHNSON   MARY      B 2345678901234567890123456789012345678901\n00003WILLIAMS  ROBERT    C 3456789012345678901234567890123456789012\n00004BROWN     PATRICIA  D 4567890123456789012345678901234567890123\n00005JONES     MICHAEL   E 5678901234567890123456789012345678901234\n00006GARCIA    LINDA     F 6789012345678901234567890123456789012345\n00007MILLER    DAVID     G 7890123456789012345678901234567890123456\n99999END       PROCESS   Z 9999999999999999999999999999999999999999"
  }
}