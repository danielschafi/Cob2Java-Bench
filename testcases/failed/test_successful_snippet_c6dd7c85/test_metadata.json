{
  "cobol_file": {
    "file_name": "successful_snippet_c6dd7c85.cob",
    "content": "       identification division.\n       program-id. snake.\n\n       data division.\n       working-storage section.\n      *>Constant ASCII codes\n       01 ASCII-W pic 9(1) usage is comp value 119.\n       01 ASCII-A pic 9(1) usage is comp value 97.\n       01 ASCII-S pic 9(1) usage is comp value 115.\n       01 ASCII-D pic 9(1) usage is comp value 100.\n       01 ASCII-Q pic 9(1) usage is comp value 113.\n      *>Constant codes for cur-direction\n       01 DIR-UP pic 9(1) value 1.\n       01 DIR-LEFT pic 9(1) value 2.\n       01 DIR-DOWN pic 9(1) value 3.\n       01 DIR-RIGHT pic 9(1) value 4.\n      *>Constant visual symbols\n       01 VIS-SNAKE pic x(1) value \"o\".\n       01 VIS-FOOD pic x(1) value \"#\".\n       01 VIS-BLANK pic x(1) value \".\".\n\n       01 input-char pic 9(8) usage is comp.\n       01 old-direction pic 9(1) value 3.\n       01 cur-direction pic 9(1) value 3.\n\n      *> The snake, board is 10x10, max-length is 100\n       01 snake.\n             05 snake-part occurs 100 times indexed by snake-index.\n             10 snake-x pic 9(2).\n             10 snake-y pic 9(2).\n       01 snake-len pic 9(3) usage is comp value 1.\n       01 next-snake-pos.\n             10 next-snake-x pic 9(2).\n             10 next-snake-y pic 9(2).\n\n       01 food.\n             05 food-x pic 9(2).\n             05 food-y pic 9(2).\n\n       01 game-screen.\n             05 screen-row occurs 10 times.\n             10 screen-pixel pic x(1) value '.' occurs 10 times.\n      *> Puts a newline after each row for printing\n             10 screen-nl pic 9(1) usage is comp value 10.\n      *> Puts a null after at the end for printing\n             05 screen-null pic 9(1) usage is comp value 0.\n\n       01 create-more-food pic 9(1) value 1.\n       01 snake-grew pic 9(1) value 1.\n\n      *> To limit FPS\n       01 ms-count pic 9(3) usage is comp.\n       01 ms-move-time pic 9(3) usage is comp value 350.\n\n       procedure division.\n       main-para.\n           call \"initscr\".\n           call \"noecho\".\n           call \"timeout\" using by value 0.\n\n           move VIS-SNAKE to screen-pixel(1, 1).\n           move 1 to snake-x(1), snake-y(1).\n           perform game-loop with test after until input-char = ASCII-Q.\n\n           perform game-over.\n\n       game-over.\n           call \"endwin\".\n           display \"Game over man, GAME OVER! Score: \"snake-len.\n           stop run.\n\n       game-loop.\n           if create-more-food = 1 then\n                 perform create-food\n           end-if.\n\n           call \"clear\".\n           perform draw.\n           perform input-para.\n\n           if ms-count > ms-move-time then\n                 perform handle-move\n                 move 0 to ms-count\n           end-if.\n\n           call \"usleep\" using by value 1.\n           add 1 to ms-count.\n\n       input-para.\n           call \"getch\" returning input-char.\n\n           evaluate true\n               when input-char = ASCII-W and not old-direction =\n                     DIR-DOWN\n                   move DIR-UP to cur-direction\n               when input-char = ASCII-A and not old-direction =\n                     DIR-RIGHT\n                   move DIR-LEFT to cur-direction\n               when input-char = ASCII-S and not old-direction =\n                     DIR-UP\n                   move DIR-DOWN to cur-direction\n               when input-char = ASCII-D and not old-direction =\n                     DIR-LEFT\n                   move DIR-RIGHT to cur-direction\n           end-evaluate.\n\n       create-food.\n           perform generate-food-location until screen-pixel(food-y,\n           food-x) = VIS-BLANK.\n           move VIS-FOOD to screen-pixel(food-y, food-x).\n           move 0 to create-more-food.\n\n       generate-food-location.\n      *> Random isn't seeded\n           compute food-x = function random * 10 + 1.\n           compute food-y = function random * 10 + 1.\n\n       draw.\n           call \"printw\" using game-screen.\n           call \"printw\" using \"Score: %d\", by value snake-len.\n\n       shift-snake.\n           compute snake-x(snake-index) = snake-x(snake-index - 1).\n           compute snake-y(snake-index) = snake-y(snake-index - 1).\n\n       handle-move.\n           perform get-next-pos.\n\n           move 0 to snake-grew.\n\n           if screen-pixel(next-snake-y, next-snake-x) = \"o\" then\n                 perform game-over\n           else\n                 if next-snake-x = food-x and next-snake-y = food-y then\n                       add 1 to snake-len\n                       compute snake-x(snake-len) = snake-x(\n                             snake-len - 1)\n                       compute snake-y(snake-len) = snake-y(\n                             snake-len - 1)\n                       move 1 to create-more-food\n                       move 1 to snake-grew\n                  end-if\n           end-if.\n\n           move VIS-SNAKE to screen-pixel(next-snake-y, next-snake-x).\n           if snake-grew = 0 then\n                 move VIS-BLANK to screen-pixel(snake-y(snake-len),\n                       snake-x(snake-len))\n           end-if.\n\n           perform shift-snake varying snake-index from snake-len by -1\n                 until snake-index = 1.\n      \n           move next-snake-x to snake-x(1).\n           move next-snake-y to snake-y(1).\n           \n           move cur-direction to old-direction.\n\n       get-next-pos.\n           move snake-x(1) to next-snake-x.\n           move snake-y(1) to next-snake-y.\n           evaluate true\n               when cur-direction = DIR-UP\n                   perform get-next-pos-up\n               when cur-direction = DIR-LEFT\n                   perform get-next-pos-left\n               when cur-direction = DIR-DOWN\n                   perform get-next-pos-down\n               when cur-direction = DIR-RIGHT\n                   perform get-next-pos-right\n           end-evaluate.\n\n       get-next-pos-up.\n           if snake-y(1) = 1 then\n                 move 10 to next-snake-y\n           else\n                 subtract 1 from snake-y(1) giving next-snake-y\n           end-if.\n\n       get-next-pos-left.\n           if snake-x(1) = 1 then\n                 move 10 to next-snake-x\n           else\n                 subtract 1 from snake-x(1) giving next-snake-x\n           end-if.\n\n       get-next-pos-down.\n           if snake-y(1) = 10 then\n                 move 1 to next-snake-y\n           else\n                 add 1 to snake-y(1) giving next-snake-y\n           end-if.\n\n       get-next-pos-right.\n           if snake-x(1) = 10 then\n                 move 1 to next-snake-x\n           else\n                 add 1 to snake-x(1) giving next-snake-x\n           end-if.\n"
  },
  "input_files": [],
  "output_files": [],
  "input_output_files": [],
  "sysin_file": null
}