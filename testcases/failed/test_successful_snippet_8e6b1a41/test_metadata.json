{
  "cobol_file": {
    "file_name": "successful_snippet_8e6b1a41.cob",
    "content": "        >>source format is free\nidentification division.\nprogram-id. brainfuck.\n\nenvironment division.\nconfiguration section.\nrepository.\n    function char trim ord intrinsic.\n\ninput-output section.\nfile-control.\n    select Source-File assign to dynamic file-arg\n        file status is file-status.\n\ndata division.\nfile section.\n    fd Source-File.\n    01 fs-source-file.\n        02 fs-instruction  pic X.\n\nworking-storage section.\n    01 tmp-input       pic X.\n    01 file-arg        pic X(255) value is space.\n    01 file-status     pic 99.\n    01 source-len      pic 999 value is zero.\n    01 brainfuck.\n        02 brainfuck-counter      usage is binary-int.\n        02 brainfuck-tape         usage is binary-char unsigned\n                                  occurs 30000 times indexed by brainfuck-dptr.\n        02 brainfuck-hoisted-iptr usage is index.\n        02 brainfuck-last-instr   pic X.\n        02 brainfuck-code         occurs 0 to 16384 times depending on source-len\n                                  indexed by brainfuck-iptr.\n            03 brainfuck-code-instr  pic X.\n            03 brainfuck-code-value  usage is binary-int.\n            03 brainfuck-code-offset usage is index.\n\nprocedure division.\ndeclaratives.\n\nfile-error section.\nuse after standard error procedure on Source-File.\n    evaluate file-status\n        when 35    display \"cannot find file \" trim(file-arg, trailing) upon stderr\n        when other display \"error with file (\" file-status \")\" upon stderr\n    end-evaluate.\n\n    goback.\nend declaratives.\n\nmain section.\nmain-procedure.\n    display 1 upon argument-number.\n    accept file-arg from argument-value\n        on exception perform no-such-arg.\n\n    perform bf-read.\n    perform bf-run.\n\n    stop run.\n\nbf-read.\n    open input Source-File.\n\n    perform forever\n        read Source-File next record\n            at end exit perform\n        end-read\n\n        *> only add to brainfuck-code the valid brainfuck instructions\n        evaluate fs-instruction\n            when '>'\n            when '<'\n            when '+'\n            when '-'\n                add 1 to source-len\n\n                *> Aggregate sequential +, -, <, and >s onto\n                *> brainfuck-code-value.\n                if brainfuck-last-instr equals fs-instruction\n                    add 1 to brainfuck-code-value(brainfuck-iptr - 1)\n                else\n                    move fs-instruction to brainfuck-code-instr(brainfuck-iptr)\n                    move fs-instruction to brainfuck-last-instr\n                    move 1 to brainfuck-code-value(brainfuck-iptr)\n                    set brainfuck-iptr up by 1\n                end-if\n\n            when '.'\n            when ','\n            when '['\n            when ']'\n                add 1 to source-len\n                move fs-instruction to brainfuck-code-instr(brainfuck-iptr)\n                move fs-instruction to brainfuck-last-instr\n                set brainfuck-iptr up by 1\n\n        end-evaluate\n    end-perform.\n\n    close Source-File.\n\nbf-run.\n    set brainfuck-iptr to 1.\n\n    perform until brainfuck-iptr > source-len\n        evaluate brainfuck-code-instr(brainfuck-iptr)\n            when '>' set brainfuck-dptr up   by brainfuck-code-value(brainfuck-iptr)\n            when '<' set brainfuck-dptr down by brainfuck-code-value(brainfuck-iptr)\n            when '+' add      brainfuck-code-value(brainfuck-iptr) to   brainfuck-tape(brainfuck-dptr)\n            when '-' subtract brainfuck-code-value(brainfuck-iptr) from brainfuck-tape(brainfuck-dptr)\n            when '.' display char(brainfuck-tape(brainfuck-dptr) + 1) with no advancing\n            when ',' perform bf-input\n            when '[' perform bf-rbracket\n            when ']' perform bf-lbracket\n        end-evaluate\n\n        set brainfuck-iptr up by 1\n    end-perform.\n\nbf-input.\n    accept tmp-input.\n    move ord(tmp-input) to brainfuck-tape(brainfuck-dptr).\n\nbf-rbracket.\n    if brainfuck-tape(brainfuck-dptr) is zero\n        if brainfuck-code-offset(brainfuck-iptr) is not zero\n            *> We have a cached offset!\n            move brainfuck-code-offset(brainfuck-iptr) to brainfuck-iptr\n        else\n            *> Hoist the current iptr so we can cache the offset later.\n            move brainfuck-iptr to brainfuck-hoisted-iptr\n\n            move 1 to brainfuck-counter\n            perform until brainfuck-counter <= 0\n                set brainfuck-iptr up by 1\n\n                if brainfuck-iptr > source-len\n                    perform unbalanced-brackets\n                end-if\n\n                evaluate brainfuck-code-instr(brainfuck-iptr)\n                    when '[' add      1 to   brainfuck-counter\n                    when ']' subtract 1 from brainfuck-counter\n                end-evaluate\n            end-perform\n\n            *> Cache the offset so we don't have to find it again. Additionally,\n            *> cache both ends -- lbracket and rbracket.\n            move brainfuck-iptr to brainfuck-code-offset(brainfuck-hoisted-iptr)\n            move brainfuck-hoisted-iptr to brainfuck-code-offset(brainfuck-iptr)\n        end-if\n    end-if.\n\nbf-lbracket.\n    if brainfuck-tape(brainfuck-dptr) is not zero\n        if brainfuck-code-offset(brainfuck-iptr) is not zero\n            *> We have a cached offset!\n            move brainfuck-code-offset(brainfuck-iptr) to brainfuck-iptr\n        else\n            *> Hoist the current iptr so we can cache the offset later.\n            move brainfuck-iptr to brainfuck-hoisted-iptr\n\n            move 1 to brainfuck-counter\n            perform until brainfuck-counter <= 0\n                set brainfuck-iptr down by 1\n\n                if brainfuck-iptr <= 0\n                    perform unbalanced-brackets\n                end-if\n\n                evaluate brainfuck-code-instr(brainfuck-iptr)\n                    when ']' add      1 to   brainfuck-counter\n                    when '[' subtract 1 from brainfuck-counter\n                end-evaluate\n            end-perform\n\n            *> Cache the offset so we don't have to find it again. Additionally,\n            *> cache both ends -- lbracket and rbracket.\n            move brainfuck-iptr to brainfuck-code-offset(brainfuck-hoisted-iptr)\n            move brainfuck-hoisted-iptr to brainfuck-code-offset(brainfuck-iptr)\n        end-if\n    end-if.\n\nunbalanced-brackets.\n    display \"unbalanced brackets.\" upon stderr.\n    stop run returning 1.\n\nno-such-arg.\n    display \"missing 'filename' argument\" upon stderr.\n    stop run returning 1.\n\nend program brainfuck.\n"
  },
  "input_files": [],
  "output_files": [],
  "input_output_files": [],
  "sysin_file": {
    "file_name": "sysin.txt",
    "content": "/path/to/file1                                                                                                                    \n/path/to/file2                                                                                                                    \n/path/to/file3                                                                                                                    \n/path/to/file4                                                                                                                    \n/path/to/file5                                                                                                                    \n/path/to/file6                                                                                                                    \n/path/to/file7                                                                                                                    \n/path/to/file8                                                                                                                    \na                                                                                                                                 \nb                                                                                                                                 \nc                                                                                                                                 \nd                                                                                                                                 \ne                                                                                                                                 \nf                                                                                                                                 \ng                                                                                                                                 \nh"
  }
}