{
    "cobol_file": {
        "file_name": "successful_snippet_024bbdb9.cob",
        "content": "       identification division.\n       program-id. overflowing.\n\n       data division.\n       working-storage section.\n       01 bit8-sized       usage binary-char.          *> standard\n       01 bit16-sized      usage binary-short.         *> standard\n       01 bit32-sized      usage binary-long.          *> standard\n       01 bit64-sized      usage binary-double.        *> standard\n       01 bit8-unsigned    usage binary-char unsigned. *> standard\n\n       01 nebulous-size    usage binary-c-long.        *> extension\n\n       01 picture-size     picture s999.               *> standard\n\n      *> ***************************************************************\n       procedure division.\n\n      *> 32 bit signed integer\n       subtract 2147483647 from zero giving bit32-sized\n       display bit32-sized\n\n       subtract 1 from bit32-sized giving bit32-sized\n           ON SIZE ERROR display \"32bit signed SIZE ERROR\"\n       end-subtract\n      *> value was unchanged due to size error trap and trigger\n       display bit32-sized\n       display space\n\n      *> 8 bit unsigned, size tested, invalid results discarded\n       add -257 to zero giving bit8-unsigned\n           ON SIZE ERROR display \"bit8-unsigned SIZE ERROR\"\n       end-add\n       display bit8-unsigned\n\n      *> programmers can ignore the safety features\n       compute bit8-unsigned = -257\n       display \"you asked for it: \" bit8-unsigned\n       display space\n\n      *> fixed size\n       move 999 to picture-size\n       add 1 to picture-size\n           ON SIZE ERROR display \"picture-sized SIZE ERROR\"\n       end-add\n       display picture-size\n\n      *> programmers doing the following, inadvertently,\n      *>   do not stay employed at banks for long\n       move 999 to picture-size\n       add 1 to picture-size\n      *> intermediate goes to 1000, left end truncated on storage\n       display \"you asked for it: \" picture-size\n\n       add 1 to picture-size\n       display \"really? you want to keep doing this?: \" picture-size\n       display space\n\n      *> C values are undefined by spec, only minimums givens\n       display \"How many bytes in a C long? \"\n               length of nebulous-size\n               \", varies by platform\"\n       display \"Regardless, ON SIZE ERROR will catch any invalid result\"\n\n      *> on a 64bit machine, C long of 8 bytes\n       add 1 to h'ffffffffffffffff' giving nebulous-size\n           ON SIZE ERROR display \"binary-c-long SIZE ERROR\"\n       end-add\n       display nebulous-size\n      *> value will still be in initial state, GnuCOBOL initializes to 0\n      *> value now goes to 1, no size error, that ship has sailed\n       add 1 to nebulous-size\n           ON SIZE ERROR display \"binary-c-long size error\"\n       end-add\n       display \"error state is not persistent: \", nebulous-size\n\n       goback.\n       end program overflowing.\n"
    },
    "input_files": [],
    "output_files": [],
    "input_output_files": [],
    "sysin_file": null,
    "code_file": "successful_snippet_024bbdb9.cob",
    "compiled_file": "successful_snippet_024bbdb9",
    "expected_output": "-2147483647\n32bit signed SIZE ERROR\n-2147483647\n \nbit8-unsigned SIZE ERROR\n000\nyou asked for it: 001\n \npicture-sized SIZE ERROR\n+999\nyou asked for it: +000\nreally? you want to keep doing this?: +001\n \nHow many bytes in a C long? 8, varies by platform\nRegardless, ON SIZE ERROR will catch any invalid result\nbinary-c-long SIZE ERROR\n+00000000000000000000\nerror state is not persistent: +00000000000000000001\n",
    "expected_output_files": [],
    "expected_input_output_files": []
}