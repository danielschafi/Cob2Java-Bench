{
  "cobol_file": {
    "file_name": "successful_snippet_550b3558.cob",
    "content": "        >>SOURCE FORMAT FREE\n*> This code is dedicated to the public domain\n*> This is GNUCobol 2.0\nidentification division.\nprogram-id. twentyfour.\nenvironment division.\nconfiguration section.\nrepository. function all intrinsic.\ndata division.\nworking-storage section.\n01  p pic 999.\n01  p1 pic 999.\n01  p-max pic 999 value 38.\n01  program-syntax pic x(494) value\n*>statement = expression;\n        '001 001 000 n'\n    &   '002 000 004 ='\n    &   '003 005 000 n'\n    &   '004 000 002 ;'\n*>expression = term, {('+'|'-') term,};\n    &   '005 005 000 n'\n    &   '006 000 016 ='\n    &   '007 017 000 n'\n    &   '008 000 015 {'\n    &   '009 011 013 ('\n    &   '010 001 000 t'\n    &   '011 013 000 |'\n    &   '012 002 000 t'\n    &   '013 000 009 )'\n    &   '014 017 000 n'\n    &   '015 000 008 }'\n    &   '016 000 006 ;'\n*>term = factor, {('*'|'/') factor,};\n    &   '017 017 000 n'\n    &   '018 000 028 ='\n    &   '019 029 000 n'\n    &   '020 000 027 {'\n    &   '021 023 025 ('\n    &   '022 003 000 t'\n    &   '023 025 000 |'\n    &   '024 004 000 t'\n    &   '025 000 021 )'\n    &   '026 029 000 n'\n    &   '027 000 020 }'\n    &   '028 000 018 ;'\n*>factor = ('(' expression, ')' | digit,);\n    &   '029 029 000 n'\n    &   '030 000 038 ='\n    &   '031 035 037 ('\n    &   '032 005 000 t'\n    &   '033 005 000 n'\n    &   '034 006 000 t'\n    &   '035 037 000 |'\n    &   '036 000 000 n'\n    &   '037 000 031 )'\n    &   '038 000 030 ;'.\n01  filler redefines program-syntax.\n    03  p-entry occurs 038.\n        05  p-address pic 999.\n        05  filler pic x.\n        05  p-definition pic 999.\n        05  p-alternate redefines p-definition pic 999.\n        05  filler pic x.\n        05  p-matching pic 999.\n        05  filler pic x.\n        05  p-symbol pic x.\n\n01  t pic 999.\n01  t-len pic 99 value 6.\n01  terminal-symbols\n    pic x(210) value\n        '01 +                               '\n    &   '01 -                               '\n    &   '01 *                               '\n    &   '01 /                               '\n    &   '01 (                               '\n    &   '01 )                               '.\n01  filler redefines terminal-symbols.\n    03  terminal-symbol-entry occurs 6.\n        05  terminal-symbol-len pic 99.\n        05  filler pic x.\n        05  terminal-symbol pic x(32).\n\n01  nt pic 999.\n01  nt-lim pic 99 value 5.\n01  nonterminal-statements pic x(294) value\n        \"000 ....,....,....,....,....,....,....,....,....,\"\n    &   \"001 statement = expression;                      \"\n    &   \"005 expression = term, {('+'|'-') term,};        \"\n    &   \"017 term = factor, {('*'|'/') factor,};          \"\n    &   \"029 factor = ('(' expression, ')' | digit,);     \"\n    &   \"036 digit;                                       \".\n01  filler redefines nonterminal-statements.\n    03  nonterminal-statement-entry occurs 5.\n        05  nonterminal-statement-number pic 999.\n        05  filler pic x.\n        05  nonterminal-statement pic x(45).\n\n01  indent pic x(64) value all '|  '.\n01  interpreter-stack.\n    03  r pic 99. *> previous top of stack\n    03  s pic 99. *> current top of stack\n    03  s-max pic 99 value 32.\n    03  s-entry occurs 32.\n        05  filler pic x(2) value 'p='.\n        05  s-p pic 999. *> callers return address\n        05  filler pic x(4) value ' sc='.\n        05  s-start-control pic 999. *> sequence start address\n        05  filler pic x(4) value ' ec='.\n        05  s-end-control pic 999. *> sequence end address\n        05  filler pic x(4) value ' al='.\n        05  s-alternate pic 999. *> the next alternate\n        05  filler pic x(3) value ' r='.\n        05  s-result pic x. *> S success, F failure, N no result\n        05  filler pic x(3) value ' c='.\n        05  s-count pic 99. *> successes in a sequence\n        05  filler pic x(3) value ' x='.\n        05  s-repeat pic 99. *> repeats in a {} sequence\n        05  filler pic x(4) value ' nt='.\n        05  s-nt pic 99. *> current nonterminal\n\n01  language-area.\n    03  l pic 99.\n    03  l-lim pic 99.\n    03  l-len pic 99 value 1.\n    03  nd pic 9.\n    03  number-definitions.\n        05  n occurs 4 pic 9.\n    03  nu pic 9.\n    03  number-use.\n        05  u occurs 4 pic x.\n    03  statement.\n        05  c occurs 32.\n            07  c9 pic 9.\n\n01  number-validation.\n    03  p4 pic 99.\n    03  p4-lim pic 99 value 24.\n    03  permutations-4 pic x(96) value\n          '1234'\n        & '1243'\n        & '1324'\n        & '1342'\n        & '1423'\n        & '1432'\n        & '2134'\n        & '2143'\n        & '2314'\n        & '2341'\n        & '2413'\n        & '2431'\n        & '3124'\n        & '3142'\n        & '3214'\n        & '3241'\n        & '3423'\n        & '3432'\n        & '4123'\n        & '4132'\n        & '4213'\n        & '4231'\n        & '4312'\n        & '4321'.\n     03  filler redefines permutations-4.\n         05  permutation-4 occurs 24 pic x(4).\n     03  current-permutation-4 pic x(4).\n     03  cpx pic 9.\n     03  od1 pic 9.\n     03  od2 pic 9.\n     03  odx pic 9.\n     03  od-lim pic 9 value 4.\n     03  operator-definitions pic x(4) value '+-*/'.\n     03  current-operators pic x(3).\n     03  co3 pic 9.\n     03  rpx pic 9.\n     03  rpx-lim pic 9 value 4.\n     03  valid-rpn-forms pic x(28) value\n          'nnonono'\n        & 'nnnonoo'\n        & 'nnnoono'\n        & 'nnnnooo'.\n    03  filler redefines valid-rpn-forms.\n        05  rpn-form occurs 4 pic x(7).\n    03  current-rpn-form pic x(7).\n\n01  calculation-area.\n    03  osx pic 99.\n    03  operator-stack pic x(32).\n    03  oqx pic 99.\n    03  oqx1 pic 99.\n    03  output-queue pic x(32).\n    03  work-number pic s9999.\n    03  top-numerator pic s9999 sign leading separate.\n    03  top-denominator pic s9999 sign leading separate.\n    03  rsx pic 9.\n    03  result-stack occurs 8.\n        05  numerator pic s9999.\n        05  denominator pic s9999.\n\n01  error-found pic x.\n01  divide-by-zero-error pic x.\n\n*>  diagnostics\n01  NL pic x value x'0A'.\n01  NL-flag pic x value space.\n01  display-level pic x value '0'.\n01  loop-lim pic 9999 value 1500.\n01  loop-count pic 9999 value 0.\n01  message-area value spaces.\n    03  message-level pic x.\n    03  message-value pic x(128).\n\n*>  input and examples\n01  instruction pic x(32) value spaces.\n01  tsx pic 99.\n01  tsx-lim pic 99 value 14.\n01  test-statements.\n    03  filler pic x(32) value '1234;1 + 2 + 3 + 4'.\n    03  filler pic x(32) value '1234;1 * 2 * 3 * 4'.\n    03  filler pic x(32) value '1234;((1)) * (((2 * 3))) * 4'.\n    03  filler pic x(32) value '1234;((1)) * ((2 * 3))) * 4'.\n    03  filler pic x(32) value '1234;(1 + 2 + 3 + 4'.\n    03  filler pic x(32) value '1234;)1 + 2 + 3 + 4'.\n    03  filler pic x(32) value '1234;1 * * 2 * 3 * 4'.\n    03  filler pic x(32) value '5679;6 - (5 - 7) * 9'.\n    03  filler pic x(32) value '1268;((1 * (8 * 6) / 2))'.\n    03  filler pic x(32) value '4583;-5-3+(8*4)'.\n    03  filler pic x(32) value '4583;8 * 4 - 5 - 3'.\n    03  filler pic x(32) value '4583;8 * 4 - (5 + 3)'.\n    03  filler pic x(32) value '1223;1 * 3 / (2 - 2)'.\n    03  filler pic x(32) value '2468;(6 * 8) / 4 / 2'.\n01  filler redefines test-statements.\n    03  filler occurs 14.\n        05  test-numbers pic x(4).\n        05  filler pic x.\n        05  test-statement pic x(27).\n\nprocedure division.\nstart-twentyfour.\n    display 'start twentyfour'\n    perform generate-numbers\n    display 'type h <enter> to see instructions'\n    accept instruction\n    perform until instruction = spaces or 'q'\n        evaluate true\n        when instruction = 'h'\n            perform display-instructions\n        when instruction = 'n'\n            perform generate-numbers\n        when instruction(1:1) = 'm'\n            move instruction(2:4) to number-definitions\n            perform validate-number\n            if divide-by-zero-error = space\n            and 24 * top-denominator = top-numerator\n                display number-definitions ' is solved by ' output-queue(1:oqx)\n            else\n                display number-definitions ' is not solvable'\n            end-if\n        when instruction = 'd0' or 'd1' or 'd2' or 'd3'\n            move instruction(2:1) to display-level\n        when instruction = 'e'\n            display 'examples:'\n            perform varying tsx from 1 by 1\n            until tsx > tsx-lim\n                move spaces to statement\n                move test-numbers(tsx) to number-definitions\n                move test-statement(tsx) to statement\n                perform evaluate-statement\n                perform show-result\n            end-perform\n        when other\n            move instruction to statement\n            perform evaluate-statement\n            perform show-result\n        end-evaluate\n        move spaces to instruction\n        display 'instruction? ' with no advancing\n        accept instruction\n    end-perform\n\n    display 'exit twentyfour'\n    stop run\n    .\ngenerate-numbers.\n    perform with test after until divide-by-zero-error = space\n    and 24 * top-denominator = top-numerator\n        compute n(1) = random(seconds-past-midnight) * 10 *> seed\n        perform varying nd from 1 by 1 until nd > 4\n            compute n(nd) = random() * 10\n            perform until n(nd) <> 0\n                compute n(nd) = random() * 10\n            end-perform\n        end-perform\n        perform validate-number\n    end-perform\n    display NL 'numbers:' with no advancing\n    perform varying nd from 1 by 1 until nd > 4\n        display space n(nd) with no advancing\n    end-perform\n    display space\n    .\nvalidate-number.\n    perform varying p4 from 1 by 1 until p4 > p4-lim\n        move permutation-4(p4) to current-permutation-4\n        perform varying od1 from 1 by 1 until od1 > od-lim\n            move operator-definitions(od1:1) to current-operators(1:1)\n            perform varying od2 from 1 by 1 until od2 > od-lim\n                move operator-definitions(od2:1) to current-operators(2:1)\n                perform varying odx from 1 by 1 until odx > od-lim\n                    move operator-definitions(odx:1) to current-operators(3:1)\n                    perform varying rpx from 1 by 1 until rpx > rpx-lim\n                        move rpn-form(rpx) to current-rpn-form\n                        move 0 to cpx co3\n                        move spaces to output-queue\n                        move 7 to oqx\n                        perform varying oqx1 from 1 by 1 until oqx1 > oqx\n                            if current-rpn-form(oqx1:1) = 'n'\n                                add 1 to cpx\n                                move current-permutation-4(cpx:1) to nd\n                                move n(nd) to output-queue(oqx1:1)\n                            else\n                                add 1 to co3\n                                move current-operators(co3:1) to output-queue(oqx1:1)\n                            end-if\n                        end-perform\n                    end-perform\n                    perform evaluate-rpn\n                    if divide-by-zero-error = space\n                    and 24 * top-denominator = top-numerator\n                        exit paragraph\n                    end-if\n                end-perform\n            end-perform\n        end-perform\n    end-perform\n    .\ndisplay-instructions.\n    display '1)  Type h <enter> to repeat these instructions.'\n    display '2)  The program will display four randomly-generated'\n    display '    single-digit numbers and will then prompt you to enter'\n    display '    an arithmetic expression followed by <enter> to sum'\n    display '    the given numbers to 24.'\n    display '    The four numbers may contain duplicates and the entered'\n    display '    expression must reference all the generated numbers and duplicates.'\n    display '    Warning:  the program converts the entered infix expression'\n    display '    to a reverse polish notation (rpn) expression'\n    display '    which is then interpreted from RIGHT to LEFT.'\n    display '    So, for instance, 8*4 - 5 - 3 will not sum to 24.'\n    display '3)  Type n <enter> to generate a new set of four numbers.'\n    display '    The program will ensure the generated numbers are solvable.'\n    display '4)  Type m#### <enter> (e.g. m1234) to create a fixed set of numbers'\n    display '    for testing purposes.'\n    display '    The program will test the solvability of the entered numbers.'\n    display '    For example, m1234 is solvable and m9999 is not solvable.'\n    display '5)  Type d0, d1, d2 or d3 followed by <enter> to display none or'\n    display '    increasingly detailed diagnostic information as the program evaluates'\n    display '    the entered expression.'\n    display '6)  Type e <enter> to see a list of example expressions and results'\n    display '7)  Type <enter> or q <enter> to exit the program'\n    .\nshow-result.\n    if error-found = 'y'\n    or divide-by-zero-error = 'y'\n        exit paragraph\n    end-if\n    display 'statement in RPN is' space output-queue\n    evaluate true\n    when top-numerator = 0\n    when top-denominator = 0\n    when 24 * top-denominator <> top-numerator\n        display 'result (' top-numerator '/' top-denominator ') is not 24'\n    when other\n        display 'result is 24'\n    end-evaluate\n    .\nevaluate-statement.\n    compute l-lim = length(trim(statement))\n\n    display NL 'numbers:' space n(1) space n(2) space n(3) space n(4)\n    move number-definitions to number-use\n    display 'statement is' space statement\n\n    move 1 to l\n    move 0 to loop-count\n    move space to error-found\n\n    move 0 to osx oqx\n    move spaces to output-queue\n\n    move 1 to p\n    move 1 to nt\n    move 0 to s\n    perform increment-s\n    perform display-start-nonterminal\n    perform increment-p\n\n    *>===================================\n    *> interpret ebnf\n    *>===================================\n    perform until s = 0\n    or error-found = 'y'\n\n        evaluate true\n\n        when p-symbol(p) = 'n'\n        and p-definition(p) = 000 *> a variable\n           perform test-variable\n       if s-result(s) = 'S'\n               perform increment-l\n           end-if\n           perform increment-p\n\n       when p-symbol(p) = 'n'\n       and p-address(p) <> p-definition(p) *> nonterminal reference\n           move p to s-p(s)\n           move p-definition(p) to p\n\n       when p-symbol(p) = 'n'\n       and p-address(p) = p-definition(p) *> nonterminal definition\n           perform increment-s\n           perform display-start-nonterminal\n           perform increment-p\n\n        when p-symbol(p) = '=' *> nonterminal control\n            move p to s-start-control(s)\n            move p-matching(p) to s-end-control(s)\n            perform increment-p\n\n        when p-symbol(p) = ';' *> end nonterminal\n            perform display-end-control\n            perform display-end-nonterminal\n            perform decrement-s\n            if s > 0\n                evaluate true\n                when s-result(r) = 'S'\n                    perform set-success\n                when s-result(r) = 'F'\n                    perform set-failure\n                end-evaluate\n                move s-p(s) to p\n                perform increment-p\n                perform display-continue-nonterminal\n            end-if\n\n    when p-symbol(p) = '{' *> start repeat sequence\n            perform increment-s\n            perform display-start-control\n            move p to s-start-control(s)\n            move p-alternate(p) to s-alternate(s)\n            move p-matching(p) to s-end-control(s)\n            move 0 to s-count(s)\n            perform increment-p\n\n        when p-symbol(p) = '}' *> end repeat sequence\n            perform display-end-control\n            evaluate true\n            when s-result(s) = 'S' *> repeat the sequence\n                perform display-repeat-control\n                perform set-nothing\n                add 1 to s-repeat(s)\n                move s-start-control(s) to p\n                perform increment-p\n           when other\n               perform decrement-s\n               evaluate true\n               when s-result(r) = 'N'\n               and s-repeat(r) = 0 *> no result\n                   perform increment-p\n               when s-result(r) = 'N'\n               and s-repeat(r) > 0 *> no result after success\n                   perform set-success\n                   perform increment-p\n               when other *> fail the sequence\n                   perform increment-p\n               end-evaluate\n           end-evaluate\n\n        when p-symbol(p) = '(' *> start sequence\n            perform increment-s\n            perform display-start-control\n            move p to s-start-control(s)\n            move p-alternate(p) to s-alternate(s)\n            move p-matching(p) to s-end-control(s)\n            move 0 to s-count(s)\n            perform increment-p\n\n       when p-symbol(p) = ')' *> end sequence\n           perform display-end-control\n           perform decrement-s\n           evaluate true\n           when s-result(r) = 'S' *> success\n               perform set-success\n               perform increment-p\n           when s-result(r) = 'N' *> no result\n               perform set-failure\n               perform increment-p\n            when other *> fail the sequence\n               perform set-failure\n               perform increment-p\n           end-evaluate\n\n        when p-symbol(p) = '|' *> alternate\n            evaluate true\n            when s-result(s) = 'S' *> exit the sequence\n                perform display-skip-alternate\n                move s-end-control(s) to p\n            when other\n                perform display-take-alternate\n                move p-alternate(p) to s-alternate(s) *> the next alternate\n                perform increment-p\n                perform set-nothing\n            end-evaluate\n\n        when p-symbol(p) = 't' *> terminal\n            move p-definition(p) to t\n            move terminal-symbol-len(t) to t-len\n            perform display-terminal\n            evaluate true\n            when statement(l:t-len) = terminal-symbol(t)(1:t-len) *> successful match\n               perform set-success\n               perform display-recognize-terminal\n               perform process-token\n               move t-len to l-len\n               perform increment-l\n               perform increment-p\n            when s-alternate(s) <> 000 *> we are in an alternate sequence\n               move s-alternate(s) to p\n            when other *> fail the sequence\n               perform set-failure\n               move s-end-control(s) to p\n            end-evaluate\n\n        when other *> end control\n            perform display-control-failure *> shouldnt happen\n\n        end-evaluate\n\n     end-perform\n\n     evaluate true *> at end of evaluation\n     when error-found = 'y'\n         continue\n     when l <= l-lim *> not all tokens parsed\n         display 'error: invalid statement'\n         perform statement-error\n     when number-use <> spaces\n         display 'error:  not all numbers were used: ' number-use\n         move 'y' to error-found\n     end-evaluate\n    .\nincrement-l.\n    evaluate true\n    when l > l-lim *> end of statement\n        continue\n    when other\n        add l-len to l\n        perform varying l from l by 1\n        until c(l) <> space\n        or l > l-lim\n            continue\n        end-perform\n        move 1 to l-len\n        if l > l-lim\n            perform end-tokens\n        end-if\n    end-evaluate\n    .\nincrement-p.\n    evaluate true\n    when p >= p-max\n        display 'at' space p ' parse overflow'\n            space 's=<' s space s-entry(s) '>'\n        move 'y' to error-found\n    when other\n        add 1 to p\n        perform display-statement\n    end-evaluate\n    .\nincrement-s.\n    evaluate true\n    when s >= s-max\n        display 'at' space p ' stack overflow '\n            space 's=<' s space s-entry(s) '>'\n        move 'y' to error-found\n    when other\n        move s to r\n        add 1 to s\n        initialize s-entry(s)\n        move 'N' to s-result(s)\n        move p to s-p(s)\n        move nt to s-nt(s)\n    end-evaluate\n    .\ndecrement-s.\n    if s > 0\n        move s to r\n        subtract 1 from s\n        if s > 0\n            move s-nt(s) to nt\n        end-if\n    end-if\n    .\nset-failure.\n    move 'F' to s-result(s)\n    if s-count(s) > 0\n        display 'sequential parse failure'\n        perform statement-error\n    end-if\n    .\nset-success.\n    move 'S' to s-result(s)\n    add 1 to s-count(s)\n    .\nset-nothing.\n    move 'N' to s-result(s)\n    move 0 to s-count(s)\n    .\nstatement-error.\n    display statement\n    move spaces to statement\n    move '^ syntax error' to statement(l:)\n    display statement\n    move 'y' to error-found\n    .\n*>=====================\n*> twentyfour semantics\n*>=====================\ntest-variable.\n    *> check validity\n    perform varying nd from 1 by 1 until nd > 4\n    or c(l) = n(nd)\n        continue\n    end-perform\n    *> check usage\n    perform varying nu from 1 by 1 until nu > 4\n    or c(l) = u(nu)\n        continue\n    end-perform\n    evaluate true\n    when l > l-lim\n        perform set-failure\n    when c9(l) not numeric\n        perform set-failure\n    when nd > 4\n        display 'invalid number'\n        perform statement-error\n    when nu > 4\n        display 'number already used'\n        perform statement-error\n    when other\n        move space to u(nu)\n        perform set-success\n        add 1 to oqx\n        move c(l) to output-queue(oqx:1)\n    end-evaluate\n    .\n*> ==================================\n*> Dijkstra Shunting-Yard Algorithm\n*> to convert infix to rpn\n*> ==================================\nprocess-token.\n    evaluate true\n    when c(l) = '('\n        add 1 to osx\n        move c(l) to operator-stack(osx:1)\n    when c(l) = ')'\n        perform varying osx from osx by -1 until osx < 1\n        or operator-stack(osx:1) = '('\n            add 1 to oqx\n            move operator-stack(osx:1) to output-queue(oqx:1)\n        end-perform\n        if osx < 1\n            display 'parenthesis error'\n            perform statement-error\n            exit paragraph\n        end-if\n        subtract 1 from osx\n    when (c(l) = '+' or '-') and (operator-stack(osx:1) = '*' or '/')\n        *> lesser operator precedence\n        add 1 to oqx\n        move operator-stack(osx:1) to output-queue(oqx:1)\n        move c(l) to operator-stack(osx:1)\n    when other\n        *> greater operator precedence\n        add 1 to osx\n        move c(l) to operator-stack(osx:1)\n    end-evaluate\n    .\nend-tokens.\n    *> 1) copy stacked operators to the output-queue\n    perform varying osx from osx by -1 until osx < 1\n    or operator-stack(osx:1) = '('\n        add 1 to oqx\n        move operator-stack(osx:1) to output-queue(oqx:1)\n    end-perform\n    if osx > 0\n        display 'parenthesis error'\n        perform statement-error\n        exit paragraph\n    end-if\n    *> 2) evaluate the rpn statement\n    perform evaluate-rpn\n    if divide-by-zero-error = 'y'\n        display 'divide by zero error'\n    end-if\n    .\nevaluate-rpn.\n    move space to divide-by-zero-error\n    move 0 to rsx *> stack depth\n    perform varying oqx1 from 1 by 1 until oqx1 > oqx\n        if output-queue(oqx1:1) >= '1' and <= '9'\n            *> push current data onto the stack\n            add 1 to rsx\n            move top-numerator to numerator(rsx)\n            move top-denominator to denominator(rsx)\n            move output-queue(oqx1:1) to top-numerator\n            move 1 to top-denominator\n        else\n            *> apply the operation\n            evaluate true\n            when output-queue(oqx1:1) = '+'\n                compute top-numerator = top-numerator * denominator(rsx)\n                    + top-denominator * numerator(rsx)\n                compute top-denominator = top-denominator * denominator(rsx)\n            when output-queue(oqx1:1) = '-'\n                compute top-numerator = top-denominator * numerator(rsx)\n                    - top-numerator * denominator(rsx)\n                compute top-denominator = top-denominator * denominator(rsx)\n            when output-queue(oqx1:1) = '*'\n                compute top-numerator = top-numerator * numerator(rsx)\n                compute top-denominator = top-denominator * denominator(rsx)\n            when output-queue(oqx1:1) = '/'\n                compute work-number = numerator(rsx) * top-denominator\n                compute top-denominator = denominator(rsx) * top-numerator\n                if top-denominator = 0\n                    move 'y' to divide-by-zero-error\n                    exit paragraph\n                end-if\n                move work-number to top-numerator\n            end-evaluate\n            *> pop the stack\n            subtract 1 from rsx\n        end-if\n    end-perform\n    .\n*>====================\n*> diagnostic displays\n*>====================\ndisplay-start-nonterminal.\n    perform varying nt from nt-lim by -1 until nt < 1\n    or p-definition(p) = nonterminal-statement-number(nt)\n        continue\n    end-perform\n    if nt > 0\n        move '1' to NL-flag\n        string '1' indent(1:s + s) 'at ' s space p ' start ' trim(nonterminal-statement(nt))\n            into message-area perform display-message\n        move nt to s-nt(s)\n    end-if\n    .\ndisplay-continue-nonterminal.\n    move s-nt(s) to nt\n    string '1' indent(1:s + s) 'at ' s space p space p-symbol(p) ' continue ' trim(nonterminal-statement(nt)) ' with result ' s-result(s)\n            into message-area perform display-message\n    .\ndisplay-end-nonterminal.\n    move s-nt(s) to nt\n    move '2' to NL-flag\n    string '1' indent(1:s + s) 'at ' s space p ' end ' trim(nonterminal-statement(nt)) ' with result ' s-result(s)\n            into message-area perform display-message\n    .\ndisplay-start-control.\n    string '2' indent(1:s + s) 'at ' s space p ' start ' p-symbol(p) ' in ' trim(nonterminal-statement(nt))\n        into message-area perform display-message\n    .\ndisplay-repeat-control.\n    string '2' indent(1:s + s) 'at ' s space p ' repeat ' p-symbol(p) ' in ' trim(nonterminal-statement(nt))  ' with result ' s-result(s)\n        into message-area perform display-message\n    .\ndisplay-end-control.\n    string '2' indent(1:s + s) 'at ' s space p ' end ' p-symbol(p)  ' in ' trim(nonterminal-statement(nt)) ' with result ' s-result(s)\n        into message-area perform display-message\n    .\ndisplay-take-alternate.\n    string '2' indent(1:s + s) 'at ' s space p ' take alternate' ' in ' trim(nonterminal-statement(nt))\n        into message-area perform display-message\n    .\ndisplay-skip-alternate.\n    string '2' indent(1:s + s) 'at ' s space p ' skip alternate' ' in ' trim(nonterminal-statement(nt))\n        into message-area perform display-message\n    .\ndisplay-terminal.\n    string '1' indent(1:s + s) 'at ' s space p\n        ' compare ' statement(l:t-len) ' to ' terminal-symbol(t)(1:t-len)\n        ' in ' trim(nonterminal-statement(nt))\n        into message-area perform display-message\n    .\ndisplay-recognize-terminal.\n    string '1' indent(1:s + s) 'at ' s space p ' recognize terminal: ' c(l) ' in ' trim(nonterminal-statement(nt))\n        into message-area perform display-message\n    .\ndisplay-recognize-variable.\n    string '1' indent(1:s + s) 'at ' s space p ' recognize digit: ' c(l) ' in ' trim(nonterminal-statement(nt))\n        into message-area perform display-message\n    .\ndisplay-statement.\n    compute p1 = p - s-start-control(s)\n    string '3' indent(1:s + s) 'at ' s space p\n        ' statement: ' s-start-control(s) '/' p1\n        space p-symbol(p) space s-result(s)\n        ' in ' trim(nonterminal-statement(nt))\n        into message-area perform display-message\n    .\ndisplay-control-failure.\n    display loop-count space indent(1:s + s) 'at' space p ' control failure' ' in ' trim(nonterminal-statement(nt))\n    display loop-count space indent(1:s + s) '   ' 'p=<' p p-entry(p) '>'\n    display loop-count space indent(1:s + s) '   ' 's=<' s space s-entry(s) '>'\n    display loop-count space indent(1:s + s) '   ' 'l=<' l space c(l)'>'\n    perform statement-error\n    .\ndisplay-message.\n    if display-level = 1\n        move space to NL-flag\n    end-if\n    evaluate true\n    when loop-count > loop-lim *> loop control\n        display 'display count exceeds ' loop-lim\n        stop run\n    when message-level <= display-level\n        evaluate true\n        when NL-flag = '1'\n             display NL loop-count space trim(message-value)\n        when NL-flag = '2'\n             display loop-count space trim(message-value) NL\n        when other\n             display loop-count space trim(message-value)\n        end-evaluate\n    end-evaluate\n    add 1 to loop-count\n    move spaces to message-area\n    move space to NL-flag\n    .\nend program twentyfour.\n"
  },
  "input_files": [],
  "output_files": [],
  "input_output_files": [],
  "sysin_file": {
    "file_name": "sysin.txt",
    "content": "h\nadd 5 3\nsubtract 10 4\nmultiply 6 7\ndivide 20 5\nadd 100 50\nmultiply 12 12\nsubtract 99 33\nq"
  }
}