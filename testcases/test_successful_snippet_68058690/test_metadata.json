{
  "cobol_file": {
    "file_name": "successful_snippet_68058690.cob",
    "content": "      *> TECTONICS\n      *>   wget http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\n      *>   or visit https://sourceforge.net/projects/souptonuts/files\n      *>   or snag ftp://ftp.openwall.com/pub/wordlists/all.gz\n      *>      for a 5 million all language word file (a few phrases)\n      *>   cobc -xj anagrams.cob [-DMOSTWORDS -DMOREWORDS -DALLWORDS]\n      *> ***************************************************************\n       identification division.\n       program-id. anagrams.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       input-output section.\n       file-control.\n           select words-in\n           assign to wordfile\n           organization is line sequential\n           status is words-status\n           .\n\n       REPLACE ==:LETTERS:== BY ==42==.\n\n       data division.\n       file section.\n       fd words-in record is varying from 1 to :LETTERS: characters\n                             depending on word-length.\n       01 word-record.\n          05 word-data         pic x occurs 0 to :LETTERS: times\n                                     depending on word-length.\n\n       working-storage section.\n       >>IF ALLWORDS DEFINED\n       01 wordfile     constant as \"/usr/local/share/dict/all.words\".\n       01 max-words    constant as 4802100.\n\n       >>ELSE-IF MOSTWORDS DEFINED\n       01 wordfile     constant as \"/usr/local/share/dict/linux.words\".\n       01 max-words    constant as 628000.\n\n       >>ELSE-IF MOREWORDS DEFINED\n       01 wordfile     constant as \"/usr/share/dict/words\".\n       01 max-words    constant as 100000.\n\n       >>ELSE\n       01 wordfile     constant as \"unixdict.txt\".\n       01 max-words    constant as 26000.\n       >>END-IF\n\n      *> The 5 million word file needs to restrict the word length\n       >>IF ALLWORDS DEFINED\n       01 max-letters          constant as 26.\n       >>ELSE\n       01 max-letters          constant as :LETTERS:.\n       >>END-IF\n\n       01 word-length          pic 99 comp-5.\n       01 words-status         pic xx.\n          88 ok-status         values '00' thru '09'.\n          88 eof-status        value '10'.\n\n      *> sortable word by letter table\n       01 letter-index         usage index.\n       01 letter-table.\n          05 letters           occurs 1 to max-letters times\n                               depending on word-length\n                               ascending key letter\n                               indexed by letter-index.\n             10 letter         pic x.\n\n      *> table of words\n       01 sorted-index         usage index.\n       01 word-table.\n          05 word-list         occurs 0 to max-words times\n                               depending on word-tally\n                               ascending key sorted-word\n                               indexed by sorted-index.\n             10 match-count    pic 999 comp-5.\n             10 this-word      pic x(max-letters).\n             10 sorted-word    pic x(max-letters).\n       01 sorted-display       pic x(10).\n\n       01 interest-table.\n          05 interest-list     pic 9(8) comp-5\n                               occurs 0 to max-words times\n                               depending on interest-tally.\n\n       01 outer                pic 9(8) comp-5.\n       01 inner                pic 9(8) comp-5.\n       01 starter              pic 9(8) comp-5.\n       01 ender                pic 9(8) comp-5.\n       01 word-tally           pic 9(8) comp-5.\n       01 interest-tally       pic 9(8) comp-5.\n       01 tally-display        pic zz,zzz,zz9.\n\n       01 most-matches         pic 99 comp-5.\n       01 matches              pic 99 comp-5.\n       01 match-display        pic z9.\n\n      *> timing display\n       01 time-stamp.\n          05 filler            pic x(11).\n          05 timer-hours       pic 99.\n          05 filler            pic x.\n          05 timer-minutes     pic 99.\n          05 filler            pic x.\n          05 timer-seconds     pic 99.\n          05 filler            pic x.\n          05 timer-subsec      pic v9(6).\n       01 timer-elapsed        pic 9(6)v9(6).\n       01 timer-value          pic 9(6)v9(6).\n       01 timer-display        pic zzz,zz9.9(6).\n\n      *> ***************************************************************\n       procedure division.\n       main-routine.\n\n       >>IF ALLWORDS DEFINED\n           display \"** Words limited to \" max-letters \" letters **\"\n       >>END-IF\n\n       perform show-time\n\n       perform load-words\n       perform find-most\n       perform display-result\n\n       perform show-time\n       goback\n       .\n\n      *> ***************************************************************\n       load-words.\n       open input words-in\n       if not ok-status then\n           display \"error opening \" wordfile upon syserr\n           move 1 to return-code\n           goback\n       end-if\n\n       perform until exit\n           read words-in\n           if eof-status then exit perform end-if\n           if not ok-status then\n               display wordfile \" read error: \" words-status upon syserr\n           end-if\n\n           if word-length equal zero then exit perform cycle end-if\n\n       >>IF ALLWORDS DEFINED\n           move min(word-length, max-letters) to word-length\n       >>END-IF\n\n           add 1 to word-tally\n           move word-record to this-word(word-tally) letter-table\n           sort letters ascending key letter\n           move letter-table to sorted-word(word-tally)\n       end-perform\n\n       move word-tally to tally-display\n       display trim(tally-display) \" words\" with no advancing\n\n       close words-in\n       if not ok-status then\n           display \"error closing \" wordfile upon syserr\n           move 1 to return-code\n       end-if\n\n      *> sort word list by anagram check field\n       sort word-list ascending key sorted-word\n       .\n\n      *> first entry in a list will end up with highest match count\n       find-most.\n       perform varying outer from 1 by 1 until outer > word-tally\n           move 1 to matches\n           add 1 to outer giving starter\n           perform varying inner from starter by 1\n                   until sorted-word(inner) not equal sorted-word(outer)\n               add 1 to matches\n           end-perform\n           if matches > most-matches then\n               move matches to most-matches\n               initialize interest-table all to value\n               move 0 to interest-tally\n           end-if\n           move matches to match-count(outer)\n           if matches = most-matches then\n               add 1 to interest-tally\n               move outer to interest-list(interest-tally)\n           end-if\n       end-perform\n       .\n\n      *> only display the words with the most anagrams\n       display-result.\n       move interest-tally to tally-display\n       move most-matches to match-display\n       display \", most anagrams: \" trim(match-display)\n               \", with \" trim(tally-display) \" set\" with no advancing\n       if interest-tally not equal 1 then\n           display \"s\" with no advancing\n       end-if\n       display \" of interest\"\n\n       perform varying outer from 1 by 1 until outer > interest-tally\n           move sorted-word(interest-list(outer)) to sorted-display\n           display sorted-display\n                   \" [\" trim(this-word(interest-list(outer)))\n              with no advancing\n           add 1 to interest-list(outer) giving starter\n           add most-matches to interest-list(outer) giving ender\n           perform varying inner from starter by 1\n               until inner = ender\n                   display \", \" trim(this-word(inner))\n                      with no advancing\n           end-perform\n           display \"]\"\n       end-perform\n       .\n\n      *> elapsed time\n       show-time.\n       move formatted-current-date(\"YYYY-MM-DDThh:mm:ss.ssssss\")\n         to time-stamp\n       compute timer-value = timer-hours * 3600 + timer-minutes * 60\n                             + timer-seconds + timer-subsec\n       if timer-elapsed = 0 then\n           display time-stamp\n           move timer-value to timer-elapsed\n       else\n           if timer-value < timer-elapsed then\n               add 86400 to timer-value\n           end-if\n           subtract timer-elapsed from timer-value\n           move timer-value to timer-display\n           display time-stamp \", \" trim(timer-display) \" seconds\"\n       end-if\n       .\n\n       end program anagrams.\n"
  },
  "input_files": [],
  "output_files": [],
  "input_output_files": [],
  "sysin_file": null
}