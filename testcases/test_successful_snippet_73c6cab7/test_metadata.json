{
  "cobol_file": {
    "file_name": "successful_snippet_73c6cab7.cob",
    "content": "       ID Division.\n      * \n      * Copyright (C) 2021 Craig Schneiderwent.  All rights reserved.\n      * \n      * I accept no liability for damages of any kind resulting \n      * from the use of this software.  Use at your own risk.\n      *\n      * This software may be modified and distributed under the terms\n      * of the MIT license. See the LICENSE file for details.\n      *\n      * This doesn't give the right answer for the full data set, but\n      * does for the small data set.  I don't know why, and I guess\n      * I never will.\n      *\n       Program-ID. cs10b.\n       Environment Division.\n       Input-Output Section.\n       File-Control.\n           Select INPT-DATA            Assign Keyboard.\n       Data Division.\n       File Section.\n       FD  INPT-DATA.\n       01  INPT-DATA-REC-MAX PIC X(4096).\n\n       Working-Storage Section.\n       01  CONSTANTS.\n           05  MYNAME             PIC X(008)      VALUE 'cs10b'.\n\n       01  WORK-AREAS.\n           05  WS-REC-COUNT       PIC 9(009) COMP    VALUE 0.\n           05  STACK-PTR          PIC 9(009) COMP    VALUE 0.\n           05  STACK-PTR1         PIC 9(009) COMP    VALUE 0.\n           05  STACK-MAX          PIC 9(009) COMP    VALUE 0.\n           05  STACK-CURR-LVL     PIC 9(009) COMP    VALUE 0.\n           05  STACK-MAX-LVL      PIC 9(009) COMP    VALUE 0.\n           05  CHAR-PTR           PIC 9(009) COMP    VALUE 0.\n           05  COMPLETION-PTR     PIC 9(009) COMP    VALUE 1.\n           05  COMPLETION-MAX     PIC 9(009) COMP    VALUE 0.\n           05  FILE-SCORE         PIC 9(009) COMP    VALUE 0.\n           05  TOTAL-SCORE-MAX    PIC 9(018) COMP    VALUE 0.\n           05  TOTAL-SUB          PIC 9(009) COMP    VALUE 0.\n           05  PROCESS-TYPE       PIC X(004)         VALUE LOW-VALUES.\n           05  COMPLETION-CHAR    PIC X(001)         VALUE SPACE.\n           05  CLOSE-CHAR         PIC X(001)         VALUE SPACE.\n           05  THE-CHAR           PIC X(001)         VALUE SPACE.\n               88  THE-CHAR-IS-OPEN                  VALUES\n                                                     '(' '[' '{' '<'.\n               88  THE-CHAR-IS-CLOSE                 VALUES\n                                                     ')' ']' '}' '>'.\n           05  COMPLETION-LIST    PIC X(100)         VALUE SPACES.\n           05  TOTAL-SCORE-TBL.\n               10  TOTAL-SCORE\n                   OCCURS 100     PIC 9(018).\n\n       01  WS-INPT-DATA GLOBAL.\n           05  WS-INPT            PIC X(4096)        VALUE SPACES.\n\n       01  SWITCHES.\n           05  INPT-DATA-EOF-SW   PIC X(001)         VALUE 'N'.\n               88  INPT-DATA-EOF                     VALUE 'Y'.\n           05  PROCESS-SW         PIC X(004)         VALUE LOW-VALUES.\n               88  PROCESS-TEST                      VALUE 'TEST'.\n           05  BAD-RECORD-SW      PIC X(001)         VALUE 'N'.\n               88  BAD-RECORD                        VALUE 'Y'\n                                                     FALSE 'N'.\n\n       01  STACK-TABLE.\n           05  STACK-TBL OCCURS 256.\n               10  STACK          PIC X(001).\n               10  STACK-LVL      PIC 9(009)  COMP.\n\n       Procedure Division.\n           DISPLAY MYNAME SPACE FUNCTION CURRENT-DATE\n\n           ACCEPT PROCESS-TYPE FROM COMMAND-LINE\n\n           MOVE FUNCTION UPPER-CASE(PROCESS-TYPE)\n             TO PROCESS-SW\n\n           INITIALIZE TOTAL-SCORE-TBL\n           MOVE 0 TO TOTAL-SUB\n\n           OPEN INPUT INPT-DATA\n\n           PERFORM 8010-READ-INPT-DATA\n\n           PERFORM 1000-PROCESS-INPUT UNTIL INPT-DATA-EOF\n\n           CLOSE INPT-DATA\n\n           SORT TOTAL-SCORE DESCENDING TOTAL-SCORE\n\n           PERFORM VARYING TOTAL-SUB FROM 1 BY 1\n           UNTIL TOTAL-SUB > TOTAL-SCORE-MAX\n             DISPLAY MYNAME\n             ' ' TOTAL-SUB\n             ' total score ' TOTAL-SCORE(TOTAL-SUB)\n           END-PERFORM\n\n           COMPUTE TOTAL-SUB = TOTAL-SCORE-MAX / 2 + 1\n\n           DISPLAY MYNAME ' file score      ' FILE-SCORE\n           DISPLAY MYNAME ' total score     ' TOTAL-SCORE(TOTAL-SUB)\n           DISPLAY MYNAME ' records read    ' WS-REC-COUNT\n\n           GOBACK.\n\n       1000-PROCESS-INPUT.\n           SET BAD-RECORD TO FALSE\n           PERFORM VARYING CHAR-PTR FROM 1 BY 1\n           UNTIL WS-INPT(CHAR-PTR:1) = SPACE\n           OR BAD-RECORD\n             MOVE WS-INPT(CHAR-PTR:1) TO THE-CHAR\n             IF THE-CHAR-IS-OPEN\n                 ADD 1 TO STACK-PTR\n                 MOVE WS-INPT(CHAR-PTR:1) TO STACK(STACK-PTR)\n             ELSE\n                 IF STACK-PTR = 0\n                     DISPLAY MYNAME ' stack pointer 0'\n                     SET BAD-RECORD TO TRUE\n                 ELSE\n                     IF PROCESS-TEST\n                         DISPLAY \n                           MYNAME SPACE THE-CHAR SPACE STACK(STACK-PTR)\n                     END-IF\n                     EVALUATE STACK(STACK-PTR) ALSO THE-CHAR\n                       WHEN   '('              ALSO ')'\n                       WHEN   '['              ALSO ']'\n                       WHEN   '{'              ALSO '}'\n                       WHEN   '<'              ALSO '>'\n                              SUBTRACT 1 FROM STACK-PTR\n                       WHEN OTHER\n                            SET BAD-RECORD TO TRUE\n                     END-EVALUATE\n                 END-IF\n             END-IF\n           END-PERFORM\n\n           IF BAD-RECORD\n               IF PROCESS-TEST\n                   DISPLAY MYNAME ' expected close for '\n                     STACK(STACK-PTR) ' but found ' THE-CHAR ' instead'\n               END-IF\n               EVALUATE THE-CHAR\n                 WHEN ')' ADD 3     TO FILE-SCORE\n                 WHEN ']' ADD 57    TO FILE-SCORE\n                 WHEN '}' ADD 1197  TO FILE-SCORE\n                 WHEN '>' ADD 25137 TO FILE-SCORE\n               END-EVALUATE\n           ELSE\n               PERFORM 2000-COMPLETE-THE-LINE\n           END-IF\n\n           PERFORM 8010-READ-INPT-DATA\n           .\n\n       2000-COMPLETE-THE-LINE.\n           IF PROCESS-TEST\n               DISPLAY MYNAME ' record ' WS-INPT(1:CHAR-PTR)\n           END-IF\n\n           INITIALIZE\n               STACK-PTR\n               STACK-MAX-LVL\n               STACK-CURR-LVL\n               COMPLETION-PTR\n               COMPLETION-LIST\n               COMPLETION-MAX\n             ALL TO VALUE\n\n           PERFORM VARYING CHAR-PTR FROM 1 BY 1\n           UNTIL WS-INPT(CHAR-PTR:1) = SPACE\n             MOVE WS-INPT(CHAR-PTR:1) TO THE-CHAR\n             IF THE-CHAR-IS-OPEN\n                 ADD 1 TO STACK-CURR-LVL\n             END-IF\n             IF STACK-CURR-LVL < 1\n                 DISPLAY\n                   MYNAME\n                   ' logic error STACK-CURR-LVL '\n                   STACK-CURR-LVL\n                 DISPLAY MYNAME ' record ' WS-REC-COUNT\n             END-IF\n             ADD 1 TO STACK-PTR\n             MOVE THE-CHAR TO STACK(STACK-PTR)\n             MOVE STACK-CURR-LVL TO STACK-LVL(STACK-PTR)\n             IF STACK-CURR-LVL > STACK-MAX-LVL\n                 MOVE STACK-CURR-LVL TO STACK-MAX-LVL\n             END-IF\n             IF THE-CHAR-IS-CLOSE\n                 SUBTRACT 1 FROM STACK-CURR-LVL\n             END-IF\n           END-PERFORM\n\n           MOVE STACK-PTR TO STACK-MAX\n           PERFORM VARYING STACK-PTR FROM 1 BY 1\n           UNTIL STACK-PTR > STACK-MAX\n             MOVE STACK(STACK-PTR) TO THE-CHAR\n             IF THE-CHAR-IS-OPEN\n                 EVALUATE STACK(STACK-PTR)\n                   WHEN '(' MOVE ')' TO CLOSE-CHAR\n                   WHEN '[' MOVE ']' TO CLOSE-CHAR\n                   WHEN '{' MOVE '}' TO CLOSE-CHAR\n                   WHEN '<' MOVE '>' TO CLOSE-CHAR\n                 END-EVALUATE\n                 PERFORM VARYING STACK-PTR1 FROM STACK-PTR BY 1\n                 UNTIL STACK(STACK-PTR1) = SPACE\n                 OR (STACK(STACK-PTR1) = CLOSE-CHAR\n                 AND STACK-LVL(STACK-PTR1) = STACK-LVL(STACK-PTR))\n                   CONTINUE\n                 END-PERFORM\n                 IF STACK(STACK-PTR1) = SPACE\n                     PERFORM 2010-ADD-TO-COMPLETION-LIST\n                 END-IF\n             END-IF\n           END-PERFORM\n\n           IF PROCESS-TEST\n               DISPLAY MYNAME ' completion list ' COMPLETION-LIST\n           END-IF\n\n           ADD 1 TO TOTAL-SUB\n           COMPUTE COMPLETION-MAX = COMPLETION-PTR - 1\n           PERFORM VARYING COMPLETION-PTR FROM COMPLETION-MAX BY -1\n           UNTIL COMPLETION-PTR = 0\n             MULTIPLY 5 BY TOTAL-SCORE(TOTAL-SUB)\n             EVALUATE COMPLETION-LIST(COMPLETION-PTR:1)\n               WHEN ')' ADD 1 TO TOTAL-SCORE(TOTAL-SUB)\n               WHEN ']' ADD 2 TO TOTAL-SCORE(TOTAL-SUB)\n               WHEN '}' ADD 3 TO TOTAL-SCORE(TOTAL-SUB)\n               WHEN '>' ADD 4 TO TOTAL-SCORE(TOTAL-SUB)\n             END-EVALUATE\n           END-PERFORM\n\n           ADD 1 TO TOTAL-SCORE-MAX\n           .\n\n       2010-ADD-TO-COMPLETION-LIST.\n           EVALUATE STACK(STACK-PTR)\n             WHEN '(' MOVE ')' TO COMPLETION-CHAR\n             WHEN '[' MOVE ']' TO COMPLETION-CHAR\n             WHEN '{' MOVE '}' TO COMPLETION-CHAR\n             WHEN '<' MOVE '>' TO COMPLETION-CHAR\n           END-EVALUATE\n\n           STRING COMPLETION-CHAR\n             INTO COMPLETION-LIST\n             POINTER COMPLETION-PTR\n           END-STRING\n           .\n\n       8010-READ-INPT-DATA.\n           INITIALIZE WS-INPT-DATA\n           READ INPT-DATA INTO WS-INPT-DATA\n             AT END SET INPT-DATA-EOF TO TRUE\n             NOT AT END\n               ADD 1 TO WS-REC-COUNT\n           END-READ\n\n           .\n\n\n"
  },
  "input_files": [],
  "output_files": [],
  "input_output_files": [],
  "sysin_file": {
    "file_name": "sysin.txt",
    "content": "LOAD\nDUMP\nINIT\nEXIT"
  }
}