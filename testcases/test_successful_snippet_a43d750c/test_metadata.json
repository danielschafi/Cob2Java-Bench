{
  "cobol_file": {
    "file_name": "successful_snippet_a43d750c.cob",
    "content": "        >>SOURCE FORMAT FREE\n*> This code is dedicated to the public domain\n*> This is GNUCobol 2.0\nidentification division.\nprogram-id. twentyfoursolve.\nenvironment division.\nconfiguration section.\nrepository. function all intrinsic.\ninput-output section.\nfile-control.\n    select count-file\n        assign to count-file-name\n        file status count-file-status\n        organization line sequential.\ndata division.\nfile section.\nfd  count-file.\n01  count-record pic x(7).\n\nworking-storage section.\n01  count-file-name pic x(64) value 'solutioncounts'.\n01  count-file-status pic xx.\n\n01  command-area.\n    03  nd pic 9.\n    03  number-definition.\n        05  n occurs 4 pic 9.\n    03  number-definition-9 redefines number-definition\n        pic 9(4).\n    03  command-input pic x(16).\n    03  command pic x(5).\n    03  number-count pic 9999.\n    03  l1 pic 99.\n    03  l2 pic 99.\n    03  expressions pic zzz,zzz,zz9.\n\n01  number-validation.\n    03  px pic 99.\n    03  permutations value\n          '1234'\n        & '1243'\n        & '1324'\n        & '1342'\n        & '1423'\n        & '1432'\n\n        & '2134'\n        & '2143'\n        & '2314'\n        & '2341'\n        & '2413'\n        & '2431'\n\n        & '3124'\n        & '3142'\n        & '3214'\n        & '3241'\n        & '3423'\n        & '3432'\n\n        & '4123'\n        & '4132'\n        & '4213'\n        & '4231'\n        & '4312'\n        & '4321'.\n        05  permutation occurs 24 pic x(4).\n    03  cpx pic 9.\n    03  current-permutation pic x(4).\n    03  od1 pic 9.\n    03  od2 pic 9.\n    03  od3 pic 9.\n    03  operator-definitions pic x(4) value '+-*/'.\n    03  cox pic 9.\n    03  current-operators pic x(3).\n    03  rpn-forms value\n          'nnonono'\n        & 'nnonnoo'\n        & 'nnnonoo'\n        & 'nnnoono'\n        & 'nnnnooo'.\n        05  rpn-form occurs 5 pic x(7).\n    03  rpx pic 9.\n    03  current-rpn-form pic x(7).\n\n01  calculation-area.\n    03  oqx pic 99.\n    03  output-queue pic x(7).\n    03  work-number pic s9999.\n    03  top-numerator pic s9999 sign leading separate.\n    03  top-denominator pic s9999 sign leading separate.\n    03  rsx pic 9.\n    03  result-stack occurs 8.\n        05  numerator pic s9999.\n        05  denominator pic s9999.\n    03  divide-by-zero-error pic x.\n\n01  totals.\n    03  s pic 999.\n    03  s-lim pic 999 value 600.\n    03  s-max pic 999 value 0.\n    03  solution occurs 600 pic x(7).\n    03  sc pic 999.\n    03  sc1 pic 999.\n    03  sc2 pic 9.\n    03  sc-max pic 999 value 0.\n    03  sc-lim pic 999 value 600.\n    03  solution-counts value zeros.\n        05  solution-count occurs 600 pic 999.\n    03  ns pic 9999.\n    03  ns-max pic 9999 value 0.\n    03  ns-lim pic 9999 value 6561.\n    03  number-solutions occurs 6561.\n        05 ns-number pic x(4).\n        05 ns-count pic 999.\n    03  record-counts pic 9999.\n    03  total-solutions pic 9999.\n\n01  infix-area.\n    03  i pic 9.\n    03  i-s pic 9.\n    03  i-s1 pic 9.\n    03  i-work pic x(16).\n    03  i-stack occurs 7 pic x(13).\n\nprocedure division.\nstart-twentyfoursolve.\n    display 'start twentyfoursolve'\n    perform display-instructions\n    perform get-command\n    perform until command-input = spaces\n        display space\n        initialize command number-count\n        unstring command-input delimited by all space\n            into command number-count\n        move command-input to number-definition\n        move spaces to command-input\n        evaluate command\n        when 'h'\n        when 'help'\n            perform display-instructions\n        when 'list'\n            if ns-max = 0\n                perform load-solution-counts\n            end-if\n            perform list-counts\n        when 'show'\n            if ns-max = 0\n                perform load-solution-counts\n            end-if\n            perform show-numbers\n        when other\n            if number-definition-9 not numeric\n                display 'invalid number'\n            else\n                perform get-solutions\n                perform display-solutions\n            end-if\n        end-evaluate\n        if command-input = spaces\n            perform get-command\n        end-if\n    end-perform\n    display 'exit twentyfoursolve'\n    stop run\n    .\ndisplay-instructions.\n    display space\n    display 'enter a number <n> as four integers from 1-9 to see its solutions'\n    display 'enter list to see counts of solutions for all numbers'\n    display 'enter show <n> to see numbers having <n> solutions'\n    display '<enter> ends the program'\n    .\nget-command.\n    display space\n    move spaces to command-input\n    display '(h for help)?' with no advancing\n    accept command-input\n    .\nask-for-more.\n    display space\n    move 0 to l1\n    add 1 to l2\n    if l2 = 10\n        display 'more (<enter>)?' with no advancing\n        accept command-input\n        move 0 to l2\n    end-if\n    .\nlist-counts.\n    add 1 to sc-max giving sc\n    display 'there are ' sc ' solution counts'\n    display space\n    display 'solutions/numbers'\n    move 0 to l1\n    move 0 to l2\n    perform varying sc from 1 by 1 until sc > sc-max\n    or command-input <> spaces\n        if solution-count(sc) > 0\n            subtract 1 from sc giving sc1 *> offset to capture zero counts\n            display sc1 '/' solution-count(sc) space with no advancing\n            add 1 to l1\n            if l1 = 8\n                perform ask-for-more\n            end-if\n        end-if\n    end-perform\n    if l1 > 0\n        display space\n    end-if\n    .\nshow-numbers. *> with number-count solutions\n    add 1 to number-count giving sc1 *> offset for zero count\n    evaluate true\n    when number-count >= sc-max\n        display 'no number has ' number-count ' solutions'\n        exit paragraph\n    when solution-count(sc1) = 1 and number-count = 1\n        display '1 number has 1 solution'\n    when solution-count(sc1) = 1\n        display '1 number has ' number-count ' solutions'\n    when number-count = 1\n        display solution-count(sc1) ' numbers have 1 solution'\n    when other\n        display solution-count(sc1) ' numbers have ' number-count ' solutions'\n    end-evaluate\n    display space\n    move 0 to l1\n    move 0 to l2\n    perform varying ns from 1 by 1 until ns > ns-max\n    or command-input <> spaces\n        if ns-count(ns) = number-count\n            display ns-number(ns) space with no advancing\n            add 1 to l1\n            if l1 = 14\n                perform ask-for-more\n            end-if\n        end-if\n    end-perform\n    if l1 > 0\n        display space\n    end-if\n    .\ndisplay-solutions.\n    evaluate s-max\n    when 0 display number-definition ' has no solutions'\n    when 1 display number-definition ' has 1 solution'\n    when other display number-definition ' has ' s-max ' solutions'\n    end-evaluate\n    display space\n    move 0 to l1\n    move 0 to l2\n    perform varying s from 1 by 1 until s > s-max\n    or command-input <> spaces\n        *> convert rpn solution(s) to infix\n        move 0 to i-s\n        perform varying i from 1 by 1 until i > 7\n            if solution(s)(i:1) >= '1' and <= '9'\n                add 1 to i-s\n                move solution(s)(i:1) to i-stack(i-s)\n            else\n                subtract 1 from i-s giving i-s1\n                move spaces to i-work\n                string '(' i-stack(i-s1) solution(s)(i:1) i-stack(i-s) ')'\n                    delimited by space into i-work\n                move i-work to i-stack(i-s1)\n                subtract 1 from i-s\n            end-if\n        end-perform\n        display solution(s) space i-stack(1) space space with no advancing\n        add 1 to l1\n        if l1 = 3\n            perform ask-for-more\n        end-if\n    end-perform\n    if l1 > 0\n        display space\n    end-if\n    .\nload-solution-counts.\n    move 0 to ns-max *> numbers and their solution count\n    move 0 to sc-max *> solution counts\n    move spaces to count-file-status\n    open input count-file\n    if count-file-status <> '00'\n        perform create-count-file\n        move 0 to ns-max *> numbers and their solution count\n        move 0 to sc-max *> solution counts\n        open input count-file\n    end-if\n    read count-file\n    move 0 to record-counts\n    move zeros to solution-counts\n    perform until count-file-status <> '00'\n        add 1 to record-counts\n        perform increment-ns-max\n        move count-record to number-solutions(ns-max)\n        add 1 to ns-count(ns-max) giving sc *> offset 1 for zero counts\n        if sc > sc-lim\n            display 'sc ' sc ' exceeds sc-lim ' sc-lim\n            stop run\n        end-if\n        if sc > sc-max\n            move sc to sc-max\n        end-if\n        add 1 to solution-count(sc)\n        read count-file\n    end-perform\n    close count-file\n    .\ncreate-count-file.\n    open output count-file\n    display 'Counting solutions for all numbers'\n    display 'We will examine 9*9*9*9 numbers'\n    display 'For each number we will examine 4! permutations of the digits'\n    display 'For each permutation we will examine 4*4*4 combinations of operators'\n    display 'For each permutation and combination we will examine 5 rpn forms'\n    display 'We will count the number of unique solutions for the given number'\n    display 'Each number and its counts will be written to file ' trim(count-file-name)\n    compute expressions = 9*9*9*9*factorial(4)*4*4*4*5\n    display 'So we will evaluate ' trim(expressions) ' statements'\n    display 'This will take a few minutes'\n    display 'In the future if ' trim(count-file-name) ' exists, this step will be bypassed'\n    move 0 to record-counts\n    move 0 to total-solutions\n    perform varying n(1) from 1 by 1 until n(1) = 0\n        perform varying n(2) from 1 by 1 until n(2) = 0\n            display n(1) n(2) '..' *> show progress\n            perform varying n(3) from 1 by 1 until n(3) = 0\n                perform varying n(4) from 1 by 1 until n(4) = 0\n                    perform get-solutions\n                    perform increment-ns-max\n                    move number-definition to ns-number(ns-max)\n                    move s-max to ns-count(ns-max)\n                    move number-solutions(ns-max) to count-record\n                    write count-record\n                    add s-max to total-solutions\n                    add 1 to record-counts\n                    add 1 to ns-count(ns-max) giving sc *> offset by 1 for zero counts\n                    if sc > sc-lim\n                        display 'error: ' sc ' solution count exceeds ' sc-lim\n                        stop run\n                    end-if\n                    add 1 to solution-count(sc)\n                end-perform\n            end-perform\n        end-perform\n    end-perform\n    close count-file\n    display record-counts ' numbers and counts written to ' trim(count-file-name)\n    display total-solutions ' total solutions'\n    display space\n    .\nincrement-ns-max.\n    if ns-max >= ns-lim\n        display 'error: numbers exceeds ' ns-lim\n        stop run\n    end-if\n    add 1 to ns-max\n    .\nget-solutions.\n    move 0 to s-max\n    perform varying px from 1 by 1 until px > 24\n        move permutation(px) to current-permutation\n        perform varying od1 from 1 by 1 until od1 > 4\n            move operator-definitions(od1:1) to current-operators(1:1)\n            perform varying od2 from 1 by 1 until od2 > 4\n                move operator-definitions(od2:1) to current-operators(2:1)\n                perform varying od3 from 1 by 1 until od3 > 4\n                    move operator-definitions(od3:1) to current-operators(3:1)\n                    perform varying rpx from 1 by 1 until rpx > 5\n                        move rpn-form(rpx) to current-rpn-form\n                        move 0 to cpx cox\n                        move spaces to output-queue\n                        perform varying oqx from 1 by 1 until oqx > 7\n                            if current-rpn-form(oqx:1) = 'n'\n                                add 1 to cpx\n                                move current-permutation(cpx:1) to nd\n                                move n(nd) to output-queue(oqx:1)\n                            else\n                                add 1 to cox\n                                move current-operators(cox:1) to output-queue(oqx:1)\n                            end-if\n                        end-perform\n                        perform evaluate-rpn\n                        if divide-by-zero-error = space\n                        and 24 * top-denominator = top-numerator\n                            perform varying s from 1 by 1 until s > s-max\n                            or solution(s) = output-queue\n                                continue\n                            end-perform\n                            if s > s-max\n                                if s >= s-lim\n                                    display 'error: solutions ' s ' for ' number-definition ' exceeds ' s-lim\n                                    stop run\n                                end-if\n                                move s to s-max\n                                move output-queue to solution(s-max)\n                            end-if\n                        end-if\n                    end-perform\n                end-perform\n            end-perform\n        end-perform\n    end-perform\n    .\nevaluate-rpn.\n    move space to divide-by-zero-error\n    move 0 to rsx *> stack depth\n    perform varying oqx from 1 by 1 until oqx > 7\n        if output-queue(oqx:1) >= '1' and <= '9'\n            *> push the digit onto the stack\n            add 1 to rsx\n            move top-numerator to numerator(rsx)\n            move top-denominator to denominator(rsx)\n            move output-queue(oqx:1) to top-numerator\n            move 1 to top-denominator\n        else\n            *> apply the operation\n            evaluate output-queue(oqx:1)\n            when '+'\n                compute top-numerator = top-numerator * denominator(rsx)\n                    + top-denominator * numerator(rsx)\n                compute top-denominator = top-denominator * denominator(rsx)\n            when '-'\n                compute top-numerator = top-denominator * numerator(rsx)\n                    - top-numerator * denominator(rsx)\n                compute top-denominator = top-denominator * denominator(rsx)\n            when '*'\n                compute top-numerator = top-numerator * numerator(rsx)\n                compute top-denominator = top-denominator * denominator(rsx)\n            when '/'\n                compute work-number = numerator(rsx) * top-denominator\n                compute top-denominator = denominator(rsx) * top-numerator\n                if top-denominator = 0\n                    move 'y' to divide-by-zero-error\n                    exit paragraph\n                end-if\n                move work-number to top-numerator\n            end-evaluate\n            *> pop the stack\n            subtract 1 from rsx\n        end-if\n    end-perform\n    .\nend program twentyfoursolve.\n"
  },
  "input_files": [],
  "output_files": [],
  "input_output_files": [],
  "sysin_file": {
    "file_name": "sysin.txt",
    "content": "1234\n5678\nlist\nshow 0\nshow 1\n2468\nhelp"
  }
}