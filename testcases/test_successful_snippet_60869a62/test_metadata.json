{
  "cobol_file": {
    "file_name": "successful_snippet_60869a62.cob",
    "content": "       ID Division.\n      * \n      * Copyright (C) 2021 Craig Schneiderwent.  All rights reserved.\n      * \n      * I accept no liability for damages of any kind resulting \n      * from the use of this software.  Use at your own risk.\n      *\n      * This software may be modified and distributed under the terms\n      * of the MIT license. See the LICENSE file for details.\n      *\n      * Demonstrate allocation, traversal, and deallocation of a\n      * doubly-linked list.\n      *\n       Program-ID. lldemo1.\n       Environment Division.\n       Data Division.\n       Working-Storage Section.\n       01  CONSTANTS.\n           05  MYNAME             PIC X(008) VALUE 'lldemo1'.\n\n       01  WORK-AREAS.\n           05  CURR-NODE-PTR      POINTER            VALUE NULL.\n           05  WORK-NODE-PTR      POINTER            VALUE NULL.\n           05  TEMP-NODE-PTR      POINTER            VALUE NULL.\n\n       01  A-LIST.\n           05  LIST-HEAD-PTR      POINTER            VALUE NULL.\n           05  LIST-TAIL-PTR      POINTER            VALUE NULL.\n\n       Linkage Section.\n      *\n      * OpenCOBOL 1.1 (now GnuCOBOL) requires these dynamically\n      * allocated items be defined with the BASED keyword.  IBM\n      * Enterprise COBOL does not implement the BASED keyword,\n      * but does require these items to be located in the Linkage\n      * Section.\n      *\n       01  CURR-NODE BASED.\n           05  PREV-NODE-PTR      POINTER.\n           05  NEXT-NODE-PTR      POINTER.\n           05  NODE-DATA          PIC X(008)         VALUE SPACES.\n\n       01  WORK-NODE BASED.\n           05  PREV-NODE-PTR      POINTER.\n           05  NEXT-NODE-PTR      POINTER.\n           05  NODE-DATA          PIC X(008)         VALUE SPACES.\n\n       Procedure Division.\n\n           PERFORM 8010-ALLOCATE-NODE\n           MOVE 'NODE3' TO NODE-DATA OF CURR-NODE\n           SET LIST-HEAD-PTR TO CURR-NODE-PTR\n           SET LIST-TAIL-PTR TO CURR-NODE-PTR\n           SET TEMP-NODE-PTR TO CURR-NODE-PTR\n\n           PERFORM 8030-ADD-NODE-TO-TAIL-OF-LIST\n           MOVE 'NODE4' TO NODE-DATA OF CURR-NODE\n\n           PERFORM 8040-ADD-NEW-NODE-AFTER-CURR\n           MOVE 'NODE5' TO NODE-DATA OF CURR-NODE\n\n           PERFORM 8020-ADD-NODE-TO-HEAD-OF-LIST\n           MOVE 'NODE2' TO NODE-DATA OF CURR-NODE\n\n           PERFORM 8050-ADD-NEW-NODE-BEFORE-CURR\n           MOVE 'NODE1' TO NODE-DATA OF CURR-NODE\n\n           DISPLAY 'five nodes allocated'\n           PERFORM 1000-PRINT-LIST\n\n           DISPLAY 'removing list tail'\n           SET CURR-NODE-PTR TO LIST-TAIL-PTR\n           PERFORM 8060-REMOVE-CURR-NODE\n\n           DISPLAY 'four nodes allocated'\n           PERFORM 1000-PRINT-LIST\n\n           DISPLAY 'removing list head'\n           SET CURR-NODE-PTR TO LIST-HEAD-PTR\n           PERFORM 8060-REMOVE-CURR-NODE\n\n           DISPLAY 'three nodes allocated'\n           PERFORM 1000-PRINT-LIST\n\n           DISPLAY 'removing middle entry from list'\n           SET CURR-NODE-PTR TO TEMP-NODE-PTR\n           PERFORM 8060-REMOVE-CURR-NODE\n\n           DISPLAY 'free the rest of the list'\n\n           SET CURR-NODE-PTR TO LIST-HEAD-PTR\n           PERFORM UNTIL CURR-NODE-PTR = NULL\n             PERFORM 8060-REMOVE-CURR-NODE\n             SET CURR-NODE-PTR TO LIST-HEAD-PTR\n           END-PERFORM\n\n           GOBACK.\n\n       1000-PRINT-LIST.\n           SET CURR-NODE-PTR TO LIST-HEAD-PTR\n\n           PERFORM UNTIL CURR-NODE-PTR = NULL\n             SET ADDRESS OF CURR-NODE TO CURR-NODE-PTR\n             DISPLAY\n               CURR-NODE-PTR\n               ' ' NODE-DATA OF CURR-NODE\n               ' ' PREV-NODE-PTR OF CURR-NODE\n               ' ' NEXT-NODE-PTR OF CURR-NODE\n             SET CURR-NODE-PTR TO NEXT-NODE-PTR OF CURR-NODE\n           END-PERFORM\n           .\n\n       8010-ALLOCATE-NODE.\n           ALLOCATE CURR-NODE\n             INITIALIZED\n             RETURNING CURR-NODE-PTR\n\n           DISPLAY 'CURR-NODE-PTR = ' CURR-NODE-PTR\n           .\n\n       8020-ADD-NODE-TO-HEAD-OF-LIST.\n           PERFORM 8010-ALLOCATE-NODE\n\n           SET WORK-NODE-PTR TO LIST-HEAD-PTR\n           SET ADDRESS OF WORK-NODE TO WORK-NODE-PTR\n           SET PREV-NODE-PTR OF WORK-NODE TO CURR-NODE-PTR\n           SET NEXT-NODE-PTR OF CURR-NODE TO LIST-HEAD-PTR\n           SET LIST-HEAD-PTR TO CURR-NODE-PTR\n           .\n\n       8030-ADD-NODE-TO-TAIL-OF-LIST.\n           PERFORM 8010-ALLOCATE-NODE\n\n           SET WORK-NODE-PTR TO LIST-TAIL-PTR\n           SET ADDRESS OF WORK-NODE TO WORK-NODE-PTR\n           SET NEXT-NODE-PTR OF WORK-NODE TO CURR-NODE-PTR\n           SET PREV-NODE-PTR OF CURR-NODE TO LIST-TAIL-PTR\n           SET LIST-TAIL-PTR TO CURR-NODE-PTR\n           .\n\n       8040-ADD-NEW-NODE-AFTER-CURR.\n           SET WORK-NODE-PTR TO CURR-NODE-PTR\n           SET ADDRESS OF WORK-NODE TO WORK-NODE-PTR\n\n           PERFORM 8010-ALLOCATE-NODE\n           SET PREV-NODE-PTR OF CURR-NODE TO WORK-NODE-PTR\n           SET NEXT-NODE-PTR OF CURR-NODE TO NEXT-NODE-PTR OF WORK-NODE\n           SET NEXT-NODE-PTR OF WORK-NODE TO CURR-NODE-PTR\n\n           IF LIST-TAIL-PTR = WORK-NODE-PTR\n               SET LIST-TAIL-PTR TO CURR-NODE-PTR\n           END-IF\n           .\n\n       8050-ADD-NEW-NODE-BEFORE-CURR.\n           SET WORK-NODE-PTR TO CURR-NODE-PTR\n           SET ADDRESS OF WORK-NODE TO WORK-NODE-PTR\n\n           PERFORM 8010-ALLOCATE-NODE\n           SET NEXT-NODE-PTR OF CURR-NODE TO WORK-NODE-PTR\n           SET PREV-NODE-PTR OF CURR-NODE TO PREV-NODE-PTR OF WORK-NODE\n           SET PREV-NODE-PTR OF WORK-NODE TO CURR-NODE-PTR\n\n           IF LIST-HEAD-PTR = WORK-NODE-PTR\n               SET LIST-HEAD-PTR TO CURR-NODE-PTR\n           END-IF\n           .\n\n      *\n      * node1 prev-node-ptr = null   next-node-ptr = @node2\n      * node2 prev-node-ptr = @node1 next-node-ptr = @node3\n      * node3 prev-node-ptr = @node2 next-node-ptr = null\n      * aList list-head-ptr = @node1 list-tail-ptr = @node3\n      *\n      * if curr-node-ptr = @node1\n      *     node2 prev-node-ptr = null   next-node-ptr = @node3\n      *     node3 unchanged\n      *     aList list-head-ptr = @node2 list-tail-ptr = @node3\n      *     free @node1\n      * end-if\n      *\n      * if curr-node-ptr = @node2\n      *     node1 prev-node-ptr = null   next-node-ptr = @node3\n      *     node3 prev-node-ptr = @node1 next-node-ptr = null\n      *     aList list-head-ptr = @node1 list-tail-ptr = @node3\n      *     free @node2\n      * end-if\n      *\n      * if curr-node-ptr = @node3\n      *     node1 unchanged\n      *     node2 prev-node-ptr = @node1 next-node-ptr = null\n      *     aList list-head-ptr = @node1 list-tail-ptr = @node2\n      *     free @node3\n      * end-if\n      *\n      *\n      *\n      *\n       8060-REMOVE-CURR-NODE.\n           SET ADDRESS OF CURR-NODE TO CURR-NODE-PTR\n\n           IF NEXT-NODE-PTR OF CURR-NODE = NULL\n               CONTINUE\n           ELSE\n               SET ADDRESS OF WORK-NODE TO NEXT-NODE-PTR OF CURR-NODE\n               SET PREV-NODE-PTR OF WORK-NODE\n                TO PREV-NODE-PTR OF CURR-NODE\n           END-IF\n\n           IF PREV-NODE-PTR OF CURR-NODE = NULL\n               CONTINUE\n           ELSE\n               SET ADDRESS OF WORK-NODE TO PREV-NODE-PTR OF CURR-NODE\n               SET NEXT-NODE-PTR OF WORK-NODE\n                TO NEXT-NODE-PTR OF CURR-NODE\n           END-IF\n\n           IF LIST-HEAD-PTR = CURR-NODE-PTR\n               SET LIST-HEAD-PTR TO NEXT-NODE-PTR OF CURR-NODE\n           END-IF\n\n           IF LIST-TAIL-PTR = CURR-NODE-PTR\n               SET LIST-TAIL-PTR TO PREV-NODE-PTR OF CURR-NODE\n           END-IF\n\n           DISPLAY 'freeing ' CURR-NODE-PTR\n           FREE CURR-NODE-PTR\n           .\n"
  },
  "input_files": [],
  "output_files": [],
  "input_output_files": [],
  "sysin_file": {
    "file_name": "sysin.txt",
    "content": "I need to analyze this COBOL program to determine if it requires SYSIN input.\n\nAfter reviewing the code, I can see that:\n\n1. The program does NOT contain any ACCEPT statements that read from SYSIN\n2. The program does NOT read from any input files\n3. The program is a self-contained demonstration of doubly-linked list operations\n4. All data is hardcoded within the program itself (NODE1, NODE2, NODE3, NODE4, NODE5)\n5. The program only performs DISPLAY statements for output\n6. It uses dynamic memory allocation (ALLOCATE/FREE) to manage linked list nodes\n\nThis program does not require any SYSIN input data. It runs completely standalone with its internal data."
  }
}