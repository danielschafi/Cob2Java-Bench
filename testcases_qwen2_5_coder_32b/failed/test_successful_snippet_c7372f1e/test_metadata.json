{
  "cobol_file": {
    "file_name": "successful_snippet_c7372f1e.cob",
    "content": "       ID Division.\n      *\n      * Copyright (C) 2021 Craig Schneiderwent.  All rights reserved.\n      * \n      * I accept no liability for damages of any kind resulting \n      * from the use of this software.  Use at your own risk.\n      *\n      * This software may be modified and distributed under the terms\n      * of the MIT license. See the LICENSE file for details.\n      *\n      * Base64 decoding in the COBOL language\n      * \n      * The nested program does the decoding, this parent program\n      * provides the data to be decoded.  The separation of duties\n      * allows the nested program to be coded in a manner which is\n      * likely to be more portable between compilers.\n      *\n      * Be advised that output from this parent program includes a\n      * trailing x'0a' line feed.\n      *\n       Program-ID. b64demo2.\n       Environment Division.\n       Input-Output Section.\n       File-Control.\n           Select INPUT01 Assign To Keyboard.\n       Data Division.\n       File Section.\n       FD  INPUT01.\n       01  INPUT01-REC PIC X(49152).\n\n       Working-Storage Section.\n       01  CONSTANTS.\n           05  MYNAME             PIC X(008) VALUE 'b64demo2'.\n\n       77  WS-INPUT01-REC         PIC X(49152)       VALUE SPACES.\n       77  INPUT01-EOF-SW         PIC X(004)         VALUE 'N'.\n           88  INPUT01-EOF                           VALUE 'Y'.\n       77  IN-BUFFER-LEN          PIC 9(008)   COMP  VALUE 1.\n       77  IN-BUFFER              PIC X(49152)       VALUE LOW-VALUES.\n       77  OUT-BUFFER-LEN         PIC 9(008)   COMP  VALUE 0.\n       77  OUT-BUFFER             PIC X(32768)       VALUE LOW-VALUES.\n\n       Procedure Division.\n\n           PERFORM 1000-PROCESS-STDIN\n\n           GOBACK\n           .\n\n       1000-PROCESS-STDIN.\n           PERFORM 1010-FILL-IN-BUFFER\n\n           CALL 'B64DECOD' USING\n               IN-BUFFER-LEN\n               IN-BUFFER\n               OUT-BUFFER-LEN\n               OUT-BUFFER\n           END-CALL\n\n           IF RETURN-CODE = 0\n               DISPLAY OUT-BUFFER(1:OUT-BUFFER-LEN)\n           ELSE\n               DISPLAY 'Error in conversion'\n           END-IF\n           .\n\n       1010-FILL-IN-BUFFER.\n           OPEN INPUT INPUT01\n\n           PERFORM 8010-READ-STDIN\n\n           STRING WS-INPUT01-REC DELIMITED SPACE\n             INTO IN-BUFFER\n             POINTER IN-BUFFER-LEN\n             OVERFLOW PERFORM 9010-ABORT\n           END-STRING\n\n      *    IN-BUFFER-LEN points to the next byte to be\n      *    used in the STRING statement.  Subracting 1\n      *    makes it contain the correct length.\n           SUBTRACT 1 FROM IN-BUFFER-LEN\n\n           CLOSE INPUT01\n           .\n\n       8010-READ-STDIN.\n           READ INPUT01 INTO WS-INPUT01-REC\n             AT END SET INPUT01-EOF TO TRUE\n           END-READ\n           .\n\n       9010-ABORT.\n           MOVE 12 TO RETURN-CODE\n           GOBACK\n           .\n\n       ID Division.\n      *\n      * Copyright (C) 2021 Craig Schneiderwent.  All rights reserved.\n      * \n      * I accept no liability for damages of any kind resulting \n      * from the use of this software.  Use at your own risk.\n      *\n      * This software may be modified and distributed under the terms\n      * of the MIT license. See the LICENSE file for details.\n      *\n      * Base64 encode data passed via CALL parameters in the \n      * Linkage Section.\n      *\n      * This program presumes big-endian encoding for COMP\n      * data items, that PIC 9(015) COMP is eight bytes long,\n      * and that a byte is eight bits, but otherwise should\n      * be compatible with any current COBOL compiler.\n      *\n      * The input buffer to be encoded is limited to 48K, but\n      * this is arbitrary and can be increased to the limits\n      * of your compiler.\n      *\n      * The output buffer containing the encoded data is limited\n      * to 32K, but this is arbitrary and can be increased to\n      * accomodate an increased input buffer size subject only\n      * to the limits of your compiler.\n      *\n      * While the input must be valid base64 encoded data, it need\n      * not be padded with '=' characters so its length is a\n      * multiple of 4.\n      *\n       Program-ID. B64DECOD Is Initial.\n       Environment Division.\n       Input-Output Section.\n       Data Division.\n       Working-Storage Section.\n       01  CONSTANTS.\n           05  MYNAME             PIC X(008) VALUE 'B64DECOD'.\n           05  SIX-BIT-CHARS-VAL.\n               10  PIC X(032) VALUE 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef'.\n               10  PIC X(032) VALUE 'ghijklmnopqrstuvwxyz0123456789+/'.\n           05  SIX-BIT-CHARS-TBL\n               REDEFINES SIX-BIT-CHARS-VAL.\n               10  SIX-BIT-CHAR\n                   OCCURS 64\n                   PIC X(001).\n\n       01  WORK-AREAS.\n           05  IN-BUFFER-PTR      PIC 9(008)  COMP VALUE 1.\n           05  OUT-BUFFER-PTR     PIC 9(008)  COMP VALUE 1.\n           05  IN-BLOCK-SIZE      PIC 9(008)  COMP VALUE 0.\n           05  GROUP-OF-FOUR-SUB  PIC 9(008)  COMP VALUE 0.\n           05  GROUP-OF-FOUR-TBL.\n               10  GROUP-OF-FOUR-CHAR\n                   OCCURS 4\n                   PIC X(001).\n           05  EIGHT-BYTE-INT      PIC 9(015)  COMP VALUE ZERO.\n           05  EIGHT-BYTE-INT-BYTES\n               REDEFINES EIGHT-BYTE-INT.\n               10  EIGHT-BYTE-INT-CHAR\n                   OCCURS 8\n                   PIC X(001).\n           05  SIX-BIT-SUB            PIC 9(008) COMP VALUE ZERO.\n           05  SIX-BIT-SUB-X\n               REDEFINES SIX-BIT-SUB.\n               10                     PIC X(003).\n               10  SIX-BIT-SUB-LOW1   PIC X(001).\n           05  OUT-BLOCK-SIZE         PIC 9(004) COMP VALUE 0.\n           05  OUT-BLOCK              PIC X(004)      VALUE SPACES.\n           05  NB-GROUPS-OF-FOUR      PIC 9(004) COMP.\n           05  NB-GROUPS-OF-FOUR-R    PIC 9(004) COMP.\n\n       01  SWITCHES.\n           05  SIX-BIT-CHAR-SW        PIC X(001)      VALUE 'N'.\n               88  SIX-BIT-CHAR-FOUND                 VALUE 'Y'.\n\n       Linkage Section.\n      *\n      * The value of IN-BUFFER-LEN is presumed to be the length\n      * of the base64 encoded data in IN-BUFFER.\n      *\n       77  IN-BUFFER-LEN       PIC 9(008)  COMP.\n      *\n      * The contents of IN-BUFFER are presumed to be valid\n      * base64 encoded data.\n      *\n       77  IN-BUFFER           PIC X(49152).\n       77  OUT-BUFFER-LEN      PIC 9(008)  COMP.\n       77  OUT-BUFFER          PIC X(32768).\n\n       Procedure Division Using\n           IN-BUFFER-LEN\n           IN-BUFFER\n           OUT-BUFFER-LEN\n           OUT-BUFFER\n           .\n\n           INITIALIZE OUT-BUFFER-LEN\n           PERFORM 1000-CONVERT\n\n           GOBACK.\n\n       1000-CONVERT.\n           DIVIDE IN-BUFFER-LEN BY 4\n             GIVING NB-GROUPS-OF-FOUR\n             REMAINDER NB-GROUPS-OF-FOUR-R\n\n           MOVE 4 TO IN-BLOCK-SIZE\n\n           PERFORM 1100-CONVERT-ONE-BLOCK\n             NB-GROUPS-OF-FOUR TIMES\n\n           EVALUATE NB-GROUPS-OF-FOUR-R\n             WHEN 0 \n                    MOVE 0 TO RETURN-CODE\n             WHEN 1\n      *             Invalid base64 encoded data\n                    MOVE 12 TO RETURN-CODE\n             WHEN OTHER\n                    MOVE NB-GROUPS-OF-FOUR-R TO IN-BLOCK-SIZE\n                    PERFORM 1100-CONVERT-ONE-BLOCK\n                    MOVE 0 TO RETURN-CODE\n           END-EVALUATE\n\n           GOBACK\n           .\n\n      * \n      * COBOL has no bit shift operator, and the algorithm\n      * requires that high order bits be squished out of bytes.\n      * This is accomplished via multiplication.\n      * \n      * Presume we have, in ASCII, the characters 'Man' which have\n      * been base64 encoded as 'TWFu' (borrowing from Wikipedia).\n      * \n      * Character T        W        F        u\n      * Sextet    19       22       5        46\n      * Bits      00010011 00010110 00000101 00101110\n      * \n      * The sextet value is the 0 based index of the character in the\n      * SIX-BIT-CHAR table.\n      * \n      * This paragraph will put b'00101110' in the low order byte\n      * of EIGHT-BYTE-INT (a 64 bit big endian integer).\n      * \n      * EIGHT-BYTE-INT now looks like this...\n      *0000000000000000000000000000000000000000000000000000000000101110\n      *1       2       3       4       5       6       7       8       \n      *\n      * Multiply by 4 and the high order two bits are squished out.\n      *\n      * EIGHT-BYTE-INT now looks like this...\n      *0000000000000000000000000000000000000000000000000000000010111000\n      *1       2       3       4       5       6       7       8       \n      *\n      * Now put b'00000101' in the byte to the left of the low\n      * order byte.  \n      * \n      * EIGHT-BYTE-INT now looks like this...\n      *0000000000000000000000000000000000000000000000000000010110111000\n      *1       2       3       4       5       6       7       8       \n      *\n      * Multiply by 4, and\n      * \n      * EIGHT-BYTE-INT now looks like this...\n      *0000000000000000000000000000000000000000000000000001011011100000\n      *1       2       3       4       5       6       7       8       \n      *\n      * Now put b'00010110' into the third byte from the right.\n      * \n      * EIGHT-BYTE-INT now looks like this...\n      *0000000000000000000000000000000000000000000101100001011011100000\n      *1       2       3       4       5       6       7       8       \n      *\n      * Multiply by 4, and\n      * \n      * EIGHT-BYTE-INT now looks like this...\n      *0000000000000000000000000000000000000000010110000101101110000000\n      *1       2       3       4       5       6       7       8       \n      * \n      * Now put b'00010011' into the fourth byte from the right.\n      * \n      * EIGHT-BYTE-INT now looks like this...\n      *0000000000000000000000000000000000010011010110000101101110000000\n      *1       2       3       4       5       6       7       8       \n      * \n      * Multiply by 4, and\n      * \n      * EIGHT-BYTE-INT now looks like this...\n      *0000000000000000000000000000000001001101011000010110111000000000\n      *1       2       3       4       5       6       7       8       \n      * \n      * \n      * Bytes 5, 6, and 7 have now each had their high order two bits\n      * squished out.  Also important is that the 4 groups of 6 bits\n      * are all adjacent, leaving b'010011010110000101101110', or...\n      * \n      * 01001101 01100001 01101110\n      * \n      * Bits      01001101 01100001 01101110\n      * Decimal   77       97       110\n      * Character M        a        n\n      * \n      * \n       1100-CONVERT-ONE-BLOCK.\n           INITIALIZE\n             EIGHT-BYTE-INT\n             OUT-BLOCK-SIZE\n\n      *    GNU COBOL (OpenCOBOL) 1.1.0 gives a truncation\n      *    warning for this statement.  The reference modification\n      *    makes it okay.\n           MOVE IN-BUFFER(IN-BUFFER-PTR:IN-BLOCK-SIZE)\n             TO GROUP-OF-FOUR-TBL\n\n           PERFORM VARYING GROUP-OF-FOUR-SUB FROM IN-BLOCK-SIZE BY -1\n           UNTIL GROUP-OF-FOUR-SUB = 0\n           OR IN-BUFFER-PTR > IN-BUFFER-LEN\n             IF GROUP-OF-FOUR-CHAR(GROUP-OF-FOUR-SUB) = '='\n                 CONTINUE\n             ELSE\n                 PERFORM 1110-FIND-SIX-BIT-CHAR\n                 IF SIX-BIT-CHAR-FOUND\n      *              COBOL is 1-based, subtract 1 to get 0-based\n                     SUBTRACT 1 FROM SIX-BIT-SUB\n                     MOVE SIX-BIT-SUB-LOW1\n                       TO EIGHT-BYTE-INT-CHAR(GROUP-OF-FOUR-SUB + 4)\n                     ADD 1 TO OUT-BLOCK-SIZE\n      *              Shift Left Logical 2 bits\n                     MULTIPLY 4 BY EIGHT-BYTE-INT\n                 END-IF\n                 ADD 1 TO IN-BUFFER-PTR\n             END-IF\n           END-PERFORM\n\n      *    OUT-BLOCK-SIZE was incremented once for each input\n      *    byte, but 4 input bytes processed = 3 output bytes\n      *    3 input bytes processed = 2 output bytes, and 2\n      *    input bytes processed = 1 output byte.\n           SUBTRACT 1 FROM OUT-BLOCK-SIZE\n           STRING EIGHT-BYTE-INT-BYTES(5:OUT-BLOCK-SIZE)\n             INTO OUT-BUFFER\n             POINTER OUT-BUFFER-PTR\n           END-STRING\n\n           ADD OUT-BLOCK-SIZE TO OUT-BUFFER-LEN\n           .\n\n       1110-FIND-SIX-BIT-CHAR.\n           INITIALIZE SIX-BIT-CHAR-SW\n           INITIALIZE SIX-BIT-SUB\n\n           PERFORM\n           UNTIL SIX-BIT-SUB > LENGTH OF SIX-BIT-CHARS-TBL\n           OR SIX-BIT-CHAR-FOUND\n             ADD 1 TO SIX-BIT-SUB\n             IF SIX-BIT-CHAR(SIX-BIT-SUB) \n             = GROUP-OF-FOUR-CHAR(GROUP-OF-FOUR-SUB)\n                 SET SIX-BIT-CHAR-FOUND TO TRUE\n             END-IF\n           END-PERFORM\n           .\n\n       END PROGRAM B64DECOD.\n       END PROGRAM b64demo2.\n\n"
  },
  "input_files": [],
  "output_files": [],
  "input_output_files": [],
  "sysin_file": {
    "file_name": "sysin.txt",
    "content": "000000001\n000000002\n000000003\n000000004\n000000005\n000000006\n000000007\n000000008"
  }
}