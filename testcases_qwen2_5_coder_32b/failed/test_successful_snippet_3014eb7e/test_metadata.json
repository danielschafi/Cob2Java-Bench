{
  "cobol_file": {
    "file_name": "successful_snippet_3014eb7e.cob",
    "content": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. AdventOfCode2019-11a.\n\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n       SELECT InputFile ASSIGN TO InputPath\n       ORGANIZATION IS LINE SEQUENTIAL.\n\n       DATA DIVISION.\n       FILE SECTION.\n       FD InputFile RECORD IS VARYING IN SIZE FROM 1 TO 9999 CHARACTERS.\n       01 InputRec  PIC X(9999).\n\n       WORKING-STORAGE SECTION.\n       01 InputPath PIC X(50).\n       01 Seps      PIC 9(5).\n       01 Str       PIC X(20).\n       01 Ptr       PIC 9(5).\n\n       01 Src           PIC S9(20) VALUE IS 0 OCCURS 9999 TIMES.\n       01 SrcLen        PIC 9(5).\n       01 OpSize        PIC 9(5) VALUE IS 20.\n\n       01 Asm.\n          02 FILLER        OCCURS 9999 TIMES.\n             03 Op         PIC S9(20).\n             03 FILLER     REDEFINES Op.\n                04 OpParam PIC 9(1) OCCURS 18 TIMES.\n                04 OpCode  PIC 9(2).\n          02 OpPtr         PIC 9(20).\n          02 Inputs        PIC S9(20) OCCURS 9999 TIMES.\n          02 InputsLen     PIC 9(4).\n          02 InputPtr      PIC 9(4).\n          02 Outputs       PIC S9(20) OCCURS 9999 TIMES.\n          02 OutputsLen    PIC 9(4).\n          02 Interrupt     PIC 9(1).\n          02 RelativeBase  PIC S9(20).\n          02 RA            PIC S9(20).\n          02 RB            PIC S9(20).\n          02 RX            PIC S9(20).\n          02 RY            PIC S9(20).\n          02 RZ            PIC S9(20).\n\n       01 Abs PIC 9(3).\n       01 Ord PIC 9(3).\n       01 Dir PIC X(1).\n\n       01 Hull.\n          02 Row OCCURS 99 TIMES.\n             03 Pane OCCURS 99 TIMES.\n                04 Colour PIC 9(1) VALUE 0.\n                04 Painted PIC 9(1) VALUE 0.\n       01 TotalPainted PIC 9(4).\n\n       PROCEDURE DIVISION.\n       Begin.\n           ACCEPT InputPath FROM ARGUMENT-VALUE.\n           OPEN INPUT InputFile.\n           READ InputFile.\n           CLOSE InputFile.\n\n           PERFORM ReadAsm.\n           PERFORM ResetAsm.\n\n           MOVE 50 TO Abs.\n           MOVE 50 TO Ord.\n           MOVE 'N' TO Dir.\n\n           PERFORM FOREVER\n\n            MOVE 1 TO InputPtr\n            MOVE 1 TO InputsLen\n            MOVE Colour(Abs, Ord) TO Inputs(InputsLen)\n\n            PERFORM ExecuteAsm\n            IF Interrupt IS EQUAL TO 0 AND OpCode(OpPtr) IS EQUAL TO 99\n             EXIT PERFORM\n            END-IF\n\n            MOVE 0 TO OutputsLen\n            MOVE Outputs(1) TO Colour(Abs, Ord)\n            MOVE 1 TO Painted(Abs, Ord)\n\n            PERFORM ExecuteAsm\n            IF Interrupt IS EQUAL TO 0 AND OpCode(OpPtr) IS EQUAL TO 99\n             EXIT PERFORM\n            END-IF\n\n            MOVE 0 TO OutputsLen\n            EVALUATE Outputs(1) ALSO Dir\n             WHEN 0 ALSO 'N' MOVE 'W' TO Dir\n             WHEN 1 ALSO 'N' MOVE 'E' TO Dir\n             WHEN 0 ALSO 'S' MOVE 'E' TO Dir\n             WHEN 1 ALSO 'S' MOVE 'W' TO Dir\n             WHEN 0 ALSO 'E' MOVE 'N' TO Dir\n             WHEN 1 ALSO 'E' MOVE 'S' TO Dir\n             WHEN 0 ALSO 'W' MOVE 'S' TO Dir\n             WHEN 1 ALSO 'W' MOVE 'N' TO Dir\n            END-EVALUATE\n\n            EVALUATE Dir\n             WHEN 'N' ADD 1 TO Ord\n             WHEN 'S' SUBTRACT 1 FROM Ord\n             WHEN 'E' ADD 1 TO Abs\n             WHEN 'W' SUBTRACT 1 FROM Abs\n            END-EVALUATE\n\n           END-PERFORM.\n\n           MOVE 0 TO TotalPainted.\n           PERFORM VARYING Abs FROM 1 UNTIL Abs > 99\n            PERFORM VARYING Ord FROM 1 UNTIL Ord > 99\n             ADD Painted(Abs, Ord) TO TotalPainted\n            END-PERFORM\n           END-PERFORM.\n\n           DISPLAY TotalPainted.\n\n           STOP RUN.\n\n      * Read the program from the input file. Save it to the Src table,\n      * so any number of copies of the program can be run.\n       ReadAsm SECTION.\n           INSPECT InputRec TALLYING Seps FOR ALL \",\".\n           IF Seps < 9999\n            ADD 1 TO Seps\n           ELSE\n            MOVE 9999 TO Seps\n           END-IF.\n\n           MOVE 1 TO Ptr.\n           MOVE 0 TO SrcLen.\n           PERFORM Seps TIMES\n            UNSTRING InputRec DELIMITED BY \",\" INTO Str\n             WITH POINTER Ptr\n            END-UNSTRING\n            ADD 1 TO SrcLen\n            COMPUTE Src(SrcLen) = FUNCTION NUMVAL(Str)\n           END-PERFORM.\n\n      * Reset the current state of the program by getting a fresh copy\n      * of the instructions, and setting the pointers to 1.\n       ResetAsm SECTION.\n           MOVE 1 TO OpPtr.\n           MOVE 1 TO InputPtr.\n           MOVE 0 TO InputsLen.\n           MOVE 0 TO OutputsLen.\n           PERFORM VARYING Ptr FROM 1 UNTIL Ptr > SrcLen\n            MOVE Src(Ptr) TO Op(Ptr)\n           END-PERFORM.\n\n      * Execute the current program by executing the operation of the\n      * operation pointer. Each instruction then advance the pointer by\n      * the relevant value. Handle the interruption flag requesting the\n      * program to stop.\n       ExecuteAsm SECTION.\n           MOVE 0 TO Interrupt.\n           PERFORM UNTIL OpPtr IS GREATER THAN SrcLen\n            COMPUTE RX = OpPtr + 1\n            COMPUTE RY = OpSize - 2\n            EVALUATE OpCode(OpPtr)\n             WHEN 1  PERFORM AddInstruction\n             WHEN 2  PERFORM MultiplyInstruction\n             WHEN 3  PERFORM InputInstruction\n             WHEN 4  PERFORM OutputInstruction\n             WHEN 5  PERFORM JumpIfTrueInstruction\n             WHEN 6  PERFORM JumpIfFalseInstruction\n             WHEN 7  PERFORM LessThanInstruction\n             WHEN 8  PERFORM EqualsInstruction\n             WHEN 9  PERFORM AdjustRelativeBaseInstruction\n             WHEN 99 EXIT PERFORM\n             WHEN OTHER\n              DISPLAY \"Invalid Op\"\n              STOP RUN\n            END-EVALUATE\n            IF Interrupt IS EQUAL TO 1\n             EXIT PERFORM\n            END-IF\n           END-PERFORM.\n\n       AddInstruction SECTION.\n           PERFORM ReadParam.\n           MOVE Op(RZ) TO RB.\n           PERFORM ReadParam.\n           ADD Op(RZ) TO RB.\n           PERFORM ReadParam.\n           MOVE RB TO Op(RZ).\n           ADD 4 TO OpPtr.\n\n       MultiplyInstruction SECTION.\n           PERFORM ReadParam.\n           MOVE Op(RZ) TO RB.\n           PERFORM ReadParam.\n           MULTIPLY Op(RZ) BY RB.\n           PERFORM ReadParam.\n           MOVE RB TO Op(RZ).\n           ADD 4 TO OpPtr.\n\n       InputInstruction SECTION.\n           IF InputPtr > InputsLen\n            MOVE 1 TO Interrupt\n            EXIT SECTION\n           END-IF.\n           PERFORM ReadParam.\n           MOVE Inputs(InputPtr) TO Op(RZ).\n           ADD 1 TO InputPtr.\n           ADD 2 TO OpPtr.\n\n       OutputInstruction SECTION.\n           PERFORM ReadParam.\n           ADD 1 TO OutputsLen.\n           MOVE Op(RZ) TO Outputs(OutputsLen)\n           ADD 2 TO OpPtr.\n           MOVE 1 TO Interrupt.\n\n       JumpIfTrueInstruction SECTION.\n           PERFORM ReadParam.\n           MOVE Op(RZ) TO RB.\n           PERFORM ReadParam.\n           IF RB IS NOT EQUAL TO 0\n            COMPUTE OpPtr = Op(RZ) + 1\n           ELSE\n            ADD 3 TO OpPtr\n           END-IF.\n\n       JumpIfFalseInstruction SECTION.\n           PERFORM ReadParam.\n           MOVE Op(RZ) TO RB.\n           PERFORM ReadParam.\n           IF RB IS EQUAL TO 0\n            COMPUTE OpPtr = Op(RZ) + 1\n           ELSE\n            ADD 3 TO OpPtr\n           END-IF.\n\n       LessThanInstruction SECTION.\n           PERFORM ReadParam.\n           MOVE Op(RZ) TO RA.\n           PERFORM ReadParam.\n           MOVE Op(RZ) TO RB.\n           PERFORM ReadParam.\n           IF RA IS LESS THAN RB\n            MOVE 1 TO Op(RZ)\n           ELSE\n            MOVE 0 TO Op(RZ)\n           END-IF.\n           ADD 4 TO OpPtr.\n\n       EqualsInstruction SECTION.\n           PERFORM ReadParam.\n           MOVE Op(RZ) TO RA.\n           PERFORM ReadParam.\n           MOVE Op(RZ) TO RB.\n           PERFORM ReadParam.\n           IF RA IS EQUAL TO RB\n            MOVE 1 TO Op(RZ)\n           ELSE\n            MOVE 0 TO Op(RZ)\n           END-IF.\n           ADD 4 TO OpPtr.\n\n       AdjustRelativeBaseInstruction SECTION.\n           PERFORM ReadParam.\n           ADD Op(RZ) TO RelativeBase.\n           ADD 2 TO OpPtr.\n\n       ReadParam SECTION.\n           EVALUATE OpParam(OpPtr, RY)\n      * Position mode is a pointer.\n            WHEN 0\n             COMPUTE RZ = Op(RX) + 1\n      * Immediate mode is a value.\n            WHEN 1 \n             MOVE RX TO RZ\n      * Relative mode is a relative pointer.\n            WHEN 2\n             COMPUTE RZ = Op(RX) + RelativeBase + 1\n           END-EVALUATE\n\n           ADD 1 TO RX.\n           SUBTRACT 1 FROM RY.\n"
  },
  "input_files": [],
  "output_files": [],
  "input_output_files": [],
  "sysin_file": {
    "file_name": "sysin.txt",
    "content": "/data/input/file1.txt                                        \n/data/input/file2.txt                                        \n/data/input/file3.txt                                        \n/data/input/file4.txt                                        \n/data/input/file5.txt                                        \n/data/input/file6.txt                                        \n/data/input/file7.txt                                        \n/data/input/file8.txt"
  }
}