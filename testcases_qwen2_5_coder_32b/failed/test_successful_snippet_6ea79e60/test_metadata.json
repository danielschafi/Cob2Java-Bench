{
  "cobol_file": {
    "file_name": "successful_snippet_6ea79e60.cob",
    "content": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. AdventOfCode2019-7b.\n\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n       SELECT InputFile ASSIGN TO InputPath\n       ORGANIZATION IS LINE SEQUENTIAL.\n\n       DATA DIVISION.\n       FILE SECTION.\n       FD InputFile RECORD IS VARYING IN SIZE FROM 1 TO 9999 CHARACTERS.\n       01 InputRec  PIC X(9999).\n\n       WORKING-STORAGE SECTION.\n       01 InputPath PIC X(50).\n       01 Seps      PIC 9(5).\n       01 Str       PIC X(15).\n       01 Ptr       PIC 9(5).\n\n       01 Src           PIC S9(15) OCCURS 9999 TIMES.\n       01 SrcLen        PIC 9(5).\n\n       01 Asms             OCCURS 5 TIMES.\n          02 FILLER        OCCURS 9999 TIMES.\n             03 FILLER         PIC S9(15).\n          02 FILLER PIC 9(5).\n          02 FILLER PIC S9(15) OCCURS 99 TIMES.\n          02 FILLER PIC 9(2).\n          02 FILLER PIC 9(2).\n          02 FILLER PIC S9(15) OCCURS 99 TIMES.\n          02 FILLER PIC 9(2).\n\n       01 Asm.\n          02 FILLER        OCCURS 9999 TIMES.\n             03 Op         PIC S9(15).\n             03 FILLER     REDEFINES Op.\n                04 OpParam PIC 9(1) OCCURS 13 TIMES.\n                04 OpCode  PIC 9(2).\n          02 OpPtr         PIC 9(5).\n          02 Inputs        PIC S9(15) OCCURS 99 TIMES.\n          02 InputsLen     PIC 9(2).\n          02 InputPtr      PIC 9(2).\n          02 Outputs       PIC S9(15) OCCURS 99 TIMES.\n          02 OutputsLen    PIC 9(2).\n          02 RA            PIC S9(15).\n          02 RB            PIC S9(15).\n          02 RX            PIC S9(15).\n          02 RY            PIC S9(15).\n          02 RZ            PIC S9(15).\n\n       01 Seq              PIC 9(5).\n       01 FILLER           REDEFINES Seq.\n          02 Setting       PIC 9(1) OCCURS 5 TIMES.\n       01 ValidSeq         PIC 9(1).\n       01 Idx              PIC 9(5).\n       01 Jdx              PIC 9(5).\n       01 Asmx             PIC 9(5).\n       01 Pipe             PIC S9(15) OCCURS 99 TIMES.\n       01 PipeLen          PIC 9(2).\n       01 Interrupt        PIC 9(1).\n       01 MaxSignal        PIC 9(15).\n       01 BestSeq          PIC 9(5).\n\n       PROCEDURE DIVISION.\n       Begin.\n           ACCEPT InputPath FROM ARGUMENT-VALUE.\n           OPEN INPUT InputFile.\n           READ InputFile.\n           CLOSE InputFile.\n\n           PERFORM ReadAsm.\n\n           MOVE 0 TO MaxSignal.\n\n      * Compute the valid sequences by cycling through the potential\n      * values and skipping invalid sequences.\n           PERFORM VARYING Seq FROM 56789 UNTIL Seq GREATER THAN 98765\n            MOVE 1 TO ValidSeq\n            PERFORM VARYING Idx FROM 1 UNTIL Idx IS GREATER THAN 5\n      * Ensure each number of the sequence is between 5 and 9.\n             IF Setting(Idx) IS LESS THAN 5\n              MOVE 0 TO ValidSeq\n              EXIT PERFORM\n             END-IF\n      * Ensure there is no duplicate.\n             PERFORM VARYING Jdx FROM Idx UNTIL Jdx IS GREATER THAN 5\n              IF Idx IS NOT EQUAL TO Jdx \n               AND Setting(Idx) IS EQUAL TO Setting(Jdx)\n               MOVE 0 TO ValidSeq\n               EXIT PERFORM\n              END-IF\n             END-PERFORM\n             IF ValidSeq IS EQUAL TO 0\n              EXIT PERFORM\n             END-IF\n            END-PERFORM\n      * If the sequence is invalid, skip to the next.\n            IF ValidSeq IS EQUAL TO 0\n             EXIT PERFORM CYCLE\n            END-IF\n\n      * Reset the current state, and copy it to the saved states to\n      * initialize the 5 routines necessary to run the software.\n            PERFORM ResetAsm\n            MOVE 1 TO InputsLen\n            PERFORM VARYING Asmx FROM 1 UNTIL Asmx > 5\n             MOVE Setting(Asmx) TO Inputs (1)\n             MOVE Asm TO Asms(Asmx)\n            END-PERFORM\n\n      * Initialize the pipe with the first input.\n            MOVE 0 TO Pipe(1)\n            MOVE 1 TO PipeLen\n\n      * Cycle through the chained programs.\n            MOVE 0 TO Asmx\n            PERFORM FOREVER\n             ADD 1 TO Asmx\n             IF Asmx IS EQUAL TO 6\n              MOVE 1 TO Asmx\n             END-IF\n\n      * Move the saved state of the previous run of the Asmx program to\n      * the current state. Add the pipe content to the input table.\n             MOVE Asms(Asmx) TO Asm\n             PERFORM VARYING Ptr FROM 1 UNTIL Ptr > PipeLen\n              MOVE Pipe(Ptr) TO Inputs (InputsLen + Ptr)\n             END-PERFORM\n             ADD PipeLen TO InputsLen\n\n      * Actually execute the program.\n            PERFORM ExecuteAsm\n\n      * Save the state of the Asmx program. Add the new outputs to the\n      * pipe.\n             PERFORM VARYING Ptr FROM 1 UNTIL Ptr > OutputsLen\n              MOVE Outputs(Ptr) TO Pipe(Ptr)\n             END-PERFORM\n             MOVE OutputsLen TO PipeLen\n             MOVE 0 TO OutputsLen\n             MOVE Asm TO Asms(Asmx)\n\n      * If the program stopped due to the stop instruction and this is\n      * the last program of the chain, everything should be stopped and\n      * we've got to the end of the loop.\n             IF OpCode(OpPtr) IS EQUAL TO 99\n              AND Asmx IS EQUAL TO 5\n              EXIT PERFORM\n             END-IF\n            END-PERFORM\n\n            IF Pipe(PipeLen) IS GREATER THAN MaxSignal\n             MOVE Pipe(PipeLen) TO MaxSignal\n             MOVE Seq TO BestSeq\n            END-IF\n           END-PERFORM.\n\n           DISPLAY BestSeq.\n           DISPLAY MaxSignal.\n\n           STOP RUN.\n\n      * Read the program from the input file. Save it to the Src table,\n      * so any number of copies of the program can be run.\n       ReadAsm SECTION.\n           INSPECT InputRec TALLYING Seps FOR ALL \",\".\n           IF Seps < 9999\n            ADD 1 TO Seps\n           ELSE\n            MOVE 9999 TO Seps\n           END-IF.\n\n           MOVE 1 TO Ptr.\n           MOVE 0 TO SrcLen.\n           PERFORM Seps TIMES\n            UNSTRING InputRec DELIMITED BY \",\" INTO Str\n             WITH POINTER Ptr\n            END-UNSTRING\n            ADD 1 TO SrcLen\n            COMPUTE Src(SrcLen) = FUNCTION NUMVAL(Str)\n           END-PERFORM.\n\n      * Reset the current state of the program by getting a fresh copy\n      * of the instructions, and setting the pointers to 1.\n       ResetAsm SECTION.\n           MOVE 1 TO OpPtr.\n           MOVE 1 TO InputPtr.\n           MOVE 0 TO InputsLen.\n           MOVE 0 TO OutputsLen.\n           PERFORM VARYING Ptr FROM 1 UNTIL Ptr > SrcLen\n            MOVE Src(Ptr) TO Op(Ptr)\n           END-PERFORM.\n\n      * Execute the current program by executing the operation of the\n      * operation pointer. Each instruction then advance the pointer by\n      * the relevant value. Handle the interruption flag requesting the\n      * program to stop.\n       ExecuteAsm SECTION.\n           MOVE 0 TO Interrupt.\n           PERFORM UNTIL OpPtr IS GREATER THAN SrcLen\n            COMPUTE RX = OpPtr + 1\n            MOVE 13 TO RY\n            EVALUATE OpCode(OpPtr)\n             WHEN 1  PERFORM AddInstruction\n             WHEN 2  PERFORM MultiplyInstruction\n             WHEN 3  PERFORM InputInstruction\n             WHEN 4  PERFORM OutputInstruction\n             WHEN 5  PERFORM JumpIfTrueInstruction\n             WHEN 6  PERFORM JumpIfFalseInstruction\n             WHEN 7  PERFORM LessThanInstruction\n             WHEN 8  PERFORM EqualsInstruction\n             WHEN 99 EXIT PERFORM\n             WHEN OTHER DISPLAY \"ERROR\" STOP RUN\n            END-EVALUATE\n            IF Interrupt IS EQUAL TO 1\n             EXIT PERFORM\n            END-IF\n           END-PERFORM.\n\n       AddInstruction SECTION.\n           PERFORM ReadParam.\n           MOVE Op(RZ) TO RB.\n           PERFORM ReadParam.\n           ADD Op(RZ) TO RB.\n           PERFORM ReadParam.\n           MOVE RB TO Op(RZ).\n           ADD 4 TO OpPtr.\n\n       MultiplyInstruction SECTION.\n           PERFORM ReadParam.\n           MOVE Op(RZ) TO RB.\n           PERFORM ReadParam.\n           MULTIPLY Op(RZ) BY RB.\n           PERFORM ReadParam.\n           MOVE RB TO Op(RZ).\n           ADD 4 TO OpPtr.\n\n       InputInstruction SECTION.\n           IF InputPtr > InputsLen\n            MOVE 1 TO Interrupt\n            EXIT SECTION\n           END-IF.\n           PERFORM ReadParam.\n           MOVE Inputs(InputPtr) TO Op(RZ).\n           ADD 1 TO InputPtr.\n           ADD 2 TO OpPtr.\n\n       OutputInstruction SECTION.\n           PERFORM ReadParam.\n           ADD 1 TO OutputsLen.\n           MOVE Op(RZ) TO Outputs(OutputsLen)\n           ADD 2 TO OpPtr.\n\n       JumpIfTrueInstruction SECTION.\n           PERFORM ReadParam.\n           MOVE Op(RZ) TO RB.\n           PERFORM ReadParam.\n           IF RB IS NOT EQUAL TO 0\n            COMPUTE OpPtr = Op(RZ) + 1\n           ELSE\n            ADD 3 TO OpPtr\n           END-IF.\n\n       JumpIfFalseInstruction SECTION.\n           PERFORM ReadParam.\n           MOVE Op(RZ) TO RB.\n           PERFORM ReadParam.\n           IF RB IS EQUAL TO 0\n            COMPUTE OpPtr = Op(RZ) + 1\n           ELSE\n            ADD 3 TO OpPtr\n           END-IF.\n\n       LessThanInstruction SECTION.\n           PERFORM ReadParam.\n           MOVE Op(RZ) TO RA.\n           PERFORM ReadParam.\n           MOVE Op(RZ) TO RB.\n           PERFORM ReadParam.\n           IF RA IS LESS THAN RB\n            MOVE 1 TO Op(RZ)\n           ELSE\n            MOVE 0 TO Op(RZ)\n           END-IF.\n           ADD 4 TO OpPtr.\n\n       EqualsInstruction SECTION.\n           PERFORM ReadParam.\n           MOVE Op(RZ) TO RA.\n           PERFORM ReadParam.\n           MOVE Op(RZ) TO RB.\n           PERFORM ReadParam.\n           IF RA IS EQUAL TO RB\n            MOVE 1 TO Op(RZ)\n           ELSE\n            MOVE 0 TO Op(RZ)\n           END-IF.\n           ADD 4 TO OpPtr.\n\n       ReadParam SECTION.\n           IF OpParam(OpPtr, RY) IS EQUAL TO 0\n            COMPUTE RZ = Op(RX) + 1\n           ELSE \n            MOVE RX TO RZ\n           END-IF.\n           ADD 1 TO RX.\n           SUBTRACT 1 FROM RY.\n"
  },
  "input_files": [],
  "output_files": [],
  "input_output_files": [],
  "sysin_file": {
    "file_name": "sysin.txt",
    "content": "/data/input/file1.txt                                        \n/data/input/file2.txt                                        \n/data/input/file3.txt                                        \n/data/input/file4.txt                                        \n/data/input/file5.txt                                        \n/data/input/file6.txt                                        \n/data/input/file7.txt                                        \n/data/input/file8.txt"
  }
}