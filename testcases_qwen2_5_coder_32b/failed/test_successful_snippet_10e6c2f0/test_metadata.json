{
  "cobol_file": {
    "file_name": "successful_snippet_10e6c2f0.cob",
    "content": "        >>SOURCE FORMAT IS FREE\n\n\nidentification division.\nprogram-id. lexer.\nenvironment division.\nconfiguration section.\nrepository. function all intrinsic.\ninput-output section.\nfile-control.\n    select input-file assign using input-name\n        status input-status\n        organization line sequential.\ndata division.\n\nfile section.\nfd  input-file.\n01  input-record pic x(98).\n\nworking-storage section.\n01  input-name pic x(32).\n01  input-status pic xx.\n01  input-length pic 99.\n\n01  output-name pic x(32) value spaces.\n01  output-status pic xx.\n01  output-record pic x(64).\n\n01  line-no pic 999 value 0.\n01  col-no pic 99.\n01  col-no-max pic 99.\n01  col-increment pic 9 value 1.\n01  start-col pic 99.\n01  outx pic 99.\n01  out-lim pic 99 value 48.\n\n01  output-line value spaces.\n    03  out-line pic zzzz9.\n    03  out-column pic zzzzzz9.\n    03  message-area.\n        05  filler pic xxx.\n        05  token pic x(16).\n        05  out-value pic x(48).\n        05  out-integer redefines out-value pic zzzzz9.\n        05  out-integer1 redefines out-value pic zzzzzz9. \n\n01  error-record.\n    03  error-line pic zzzz9 value 0.\n    03  error-col pic zzzzzz9 value 0.\n    03  error-message pic x(68) value spaces.\n\n01  scan-state pic x(16) value spaces.\n01  current-character pic x.\n01  previous-character pic x.\n\nprocedure division chaining input-name.\nstart-lexer.\n    if input-name <> spaces\n        open input input-file\n        if input-status = '35'\n            string 'in lexer ' trim(input-name) ' not found' into error-message\n            perform report-error\n        end-if\n    end-if\n    perform read-input-file\n    perform until input-status <> '00'\n        add 1 to line-no\n        move line-no to out-line\n        move length(trim(input-record,trailing)) to col-no-max\n        move 1 to col-no\n        move space to previous-character\n        perform until col-no > col-no-max\n            move col-no to out-column\n            move input-record(col-no:1) to current-character\n            evaluate scan-state\n\n            when 'identifier'\n                if current-character >= 'A' and <= 'Z'\n                or (current-character >= 'a' and <= 'z')\n                or (current-character >= '0' and <= '9')\n                or current-character = '_'\n                    perform increment-outx\n                    move current-character to out-value(outx:1)\n                    if col-no = col-no-max\n                        perform process-identifier\n                    end-if\n                else\n                    perform process-identifier\n                    if current-character <> space\n                        move 0 to col-increment\n                    end-if\n                end-if\n\n            when 'integer'\n                evaluate true\n                when current-character >= '0' and <= '9'\n                    perform increment-outx\n                    move current-character to out-value(outx:1)\n                    if col-no = col-no-max\n                        move numval(out-value) to out-integer\n                        move 'Integer' to token\n                    end-if\n                when current-character >= 'A' and <= 'Z'\n                when current-character >= 'a' and <= 'z'\n                    move 'in lexer invalid integer' to error-message\n                    perform report-error\n                when other\n                    if outx > 5\n                        move numval(out-value) to out-integer1 \n                    else\n                        move numval(out-value) to out-integer\n                    end-if\n                    move 'Integer' to token\n                    if current-character <> space\n                        move 0 to col-increment\n                    end-if\n                end-evaluate\n                \n            when 'comment'\n                if previous-character = '*' and current-character = '/' \n                    move 'comment' to token\n                end-if\n\n            when 'quote'\n                evaluate current-character also outx\n                when '\"' also 0\n                    string 'in lexer empty string' into error-message\n                    perform report-error\n                when '\"' also any\n                    perform increment-outx\n                    move current-character to out-value(outx:1)\n                    move 'String' to token\n                when other\n                    if col-no = col-no-max\n                        string 'in lexer missing close quote' into error-message\n                        perform report-error\n                    else\n                        perform increment-outx\n                        move current-character to out-value(outx:1)\n                    end-if\n                end-evaluate\n\n            when 'character'\n                evaluate current-character also outx\n                when \"'\" also 0\n                    string 'in lexer empty character constant' into error-message\n                    perform report-error\n                when \"'\" also 1\n                    subtract 1 from ord(out-value(1:1)) giving out-integer\n                    move 'Integer' to token\n                when \"'\" also 2\n                    evaluate true \n                    when out-value(1:2) = '\\n'\n                        move 10 to out-integer\n                    when out-value(1:2) = '\\\\'\n                        subtract 1 from ord('\\') giving out-integer      \n                    when other\n                        string 'in lexer unknown escape sequence ' out-value(1:2)\n                            into error-message\n                        perform report-error\n                    end-evaluate\n                    move 'Integer' to token\n                when \"'\" also any\n                    string 'in lexer multicharacter constant' into error-message\n                    perform report-error\n                when other\n                    if col-no = col-no-max\n                        string 'in lexer missing close quote' into error-message\n                        perform report-error\n                    end-if\n                    perform increment-outx\n                    move current-character to out-value(outx:1)\n                end-evaluate\n\n            when 'and'\n                evaluate previous-character also current-character\n                when '&' also '&'\n                    move 'Op_and' to token\n                when other\n                    string 'in lexer AND error' into error-message\n                    perform report-error\n                end-evaluate\n\n            when 'or'\n                evaluate previous-character also current-character\n                when '|' also '|'\n                    move 'Op_or' to token\n                when other\n                    string 'in lexer OR error' into error-message\n                    perform report-error\n                end-evaluate\n\n            when 'ambiguous'\n                evaluate previous-character also current-character\n                when '/' also '*'\n                    move 'comment' to scan-state\n                    subtract 1 from col-no giving start-col\n                when '/' also any\n                    move 'Op_divide' to token\n                    move 0 to col-increment\n\n                when '=' also '='\n                    move 'Op_equal' to token\n                when '=' also any\n                    move 'Op_assign' to token\n                    move 0 to col-increment\n\n                when '<' also '='\n                    move 'Op_lessequal' to token\n                when '<' also any\n                    move 'Op_less' to token \n                    move 0 to col-increment\n\n                when '>' also '='\n                    move 'Op_greaterequal' to token\n                when '>'also any\n                    move 'Op_greater' to token\n                    move 0 to col-increment\n\n                when '!' also '='\n                    move 'Op_notequal' to token\n                when '!' also any\n                    move 'Op_not' to token\n                    move 0 to col-increment\n\n                when other\n                    display input-record\n                    string 'in lexer ' trim(scan-state)\n                        ' unknown character \"' current-character '\"'\n                        ' with previous character \"' previous-character '\"'\n                        into error-message\n                    perform report-error\n                end-evaluate\n\n            when other\n                move col-no to start-col\n                evaluate current-character\n                when space\n                    continue\n                when >= 'A' and <= 'Z'\n                when >= 'a' and <= 'z'\n                    move 'identifier' to scan-state\n                    move 1 to outx\n                    move current-character to out-value\n                when >= '0' and <= '9'\n                    move 'integer' to scan-state\n                    move 1 to outx\n                    move current-character to out-value\n                when '&'\n                    move 'and' to scan-state\n                when '|'\n                    move 'or' to scan-state\n                when '\"'\n                    move 'quote' to scan-state\n                    move 1 to outx\n                    move current-character to out-value\n                when \"'\"\n                    move 'character' to scan-state\n                    move 0 to outx\n                when '{'\n                    move 'LeftBrace' to token\n                when '}'\n                    move 'RightBrace' to token\n                when '('\n                    move 'LeftParen' to token\n                when ')'\n                    move 'RightParen' to token\n                when '+'\n                    move 'Op_add' to token\n                when '-'\n                    move 'Op_subtract' to token\n                when '*'\n                    move 'Op_multiply' to token\n                when '%'\n                    move 'Op_mod' to token\n                when ';'\n                    move 'Semicolon' to token\n                when ','\n                    move 'Comma' to token\n                when '/'\n                when '<'\n                when '>'\n                when '='\n                when '='\n                when '<'\n                when '>'\n                when '!'\n                    move 'ambiguous' to scan-state\n                when other\n                    string 'in lexer unknown character \"' current-character '\"'\n                        into error-message\n                    perform report-error\n                end-evaluate\n            end-evaluate\n\n            if token <> spaces\n                perform process-token\n            end-if\n\n            move current-character to previous-character\n            add col-increment to col-no\n            move 1 to col-increment\n        end-perform\n        if scan-state = 'ambiguous'\n            evaluate previous-character\n            when '/'\n                move 'Op_divide' to token\n                perform process-token\n\n            when '='\n                move 'Op_assign' to token\n                perform process-token\n\n            when '<'\n                move 'Op_less' to token \n                perform process-token\n\n            when '>'\n                move 'Op_greater' to token\n                perform process-token\n\n            when '!'\n                move 'Op_not' to token\n                perform process-token\n\n            when other\n                string 'in lexer unresolved ambiguous\n                    \"' previous-character '\" at end of line'\n                into error-message\n                perform report-error\n            end-evaluate\n        end-if\n        perform read-input-file\n    end-perform\n\n    evaluate true\n    when input-status <> '10'\n        string 'in lexer ' trim(input-name) ' invalid input status ' input-status\n            into error-message\n        perform report-error\n    when scan-state = 'comment'\n        string 'in lexer unclosed comment at end of input' into error-message\n        perform report-error\n     end-evaluate\n    \n    move 'End_of_input' to token\n    move 1 to out-column\n    move 1 to start-col\n    add 1 to line-no\n    perform process-token\n\n    close input-file\n    stop run\n    .\nprocess-identifier.\n    evaluate true\n    when out-value = 'print'\n        move 'Keyword_print' to token\n        move spaces to out-value\n    when out-value = 'while'\n        move 'Keyword_while' to token\n        move spaces to out-value\n    when out-value = 'if'\n        move 'Keyword_if' to token\n        move spaces to out-value\n    when out-value = 'else'\n        move 'Keyword_else' to token\n        move spaces to out-value\n    when out-value = 'putc'\n        move 'Keyword_putc' to token\n        move spaces to out-value\n    when other\n        move 'Identifier' to token\n    end-evaluate\n    .\nincrement-outx.\n    if outx >= out-lim\n        string 'in lexer token value length exceeds ' out-lim into error-message\n        perform report-error\n    end-if\n    add 1 to outx\n    .\nprocess-token.\n    if token <> 'comment'\n        move start-col to out-column\n        move line-no to out-line\n        display output-line\n    end-if\n    move 0 to start-col\n    move spaces to scan-state message-area\n    .\nreport-error.\n    move line-no to error-line\n    move start-col to error-col\n    display error-record\n    close input-file\n    stop run with error status -1\n    .\nread-input-file.\n    if input-name = spaces\n        move '00' to input-status\n        accept input-record on exception move '10' to input-status end-accept\n    else\n        read input-file\n    end-if\n    .\nend program lexer.\n"
  },
  "input_files": [],
  "output_files": [],
  "input_output_files": [],
  "sysin_file": {
    "file_name": "sysin.txt",
    "content": "000000001Customer Record One                                                                                                  \n000000002Customer Record Two                                                                                                  \n000000003Customer Record Three                                                                                               \n000000004Customer Record Four                                                                                                  \n000000005Customer Record Five                                                                                                  \n000000006Customer Record Six                                                                                                   \n000000007Customer Record Seven                                                                                                 \n000000008Customer Record Eight"
  }
}