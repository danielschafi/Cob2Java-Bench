{
    "cobol_file": {
        "file_name": "successful_snippet_60869a62.cob",
        "content": "       ID Division.\n      * \n      * Copyright (C) 2021 Craig Schneiderwent.  All rights reserved.\n      * \n      * I accept no liability for damages of any kind resulting \n      * from the use of this software.  Use at your own risk.\n      *\n      * This software may be modified and distributed under the terms\n      * of the MIT license. See the LICENSE file for details.\n      *\n      * Demonstrate allocation, traversal, and deallocation of a\n      * doubly-linked list.\n      *\n       Program-ID. lldemo1.\n       Environment Division.\n       Data Division.\n       Working-Storage Section.\n       01  CONSTANTS.\n           05  MYNAME             PIC X(008) VALUE 'lldemo1'.\n\n       01  WORK-AREAS.\n           05  CURR-NODE-PTR      POINTER            VALUE NULL.\n           05  WORK-NODE-PTR      POINTER            VALUE NULL.\n           05  TEMP-NODE-PTR      POINTER            VALUE NULL.\n\n       01  A-LIST.\n           05  LIST-HEAD-PTR      POINTER            VALUE NULL.\n           05  LIST-TAIL-PTR      POINTER            VALUE NULL.\n\n       Linkage Section.\n      *\n      * OpenCOBOL 1.1 (now GnuCOBOL) requires these dynamically\n      * allocated items be defined with the BASED keyword.  IBM\n      * Enterprise COBOL does not implement the BASED keyword,\n      * but does require these items to be located in the Linkage\n      * Section.\n      *\n       01  CURR-NODE BASED.\n           05  PREV-NODE-PTR      POINTER.\n           05  NEXT-NODE-PTR      POINTER.\n           05  NODE-DATA          PIC X(008)         VALUE SPACES.\n\n       01  WORK-NODE BASED.\n           05  PREV-NODE-PTR      POINTER.\n           05  NEXT-NODE-PTR      POINTER.\n           05  NODE-DATA          PIC X(008)         VALUE SPACES.\n\n       Procedure Division.\n\n           PERFORM 8010-ALLOCATE-NODE\n           MOVE 'NODE3' TO NODE-DATA OF CURR-NODE\n           SET LIST-HEAD-PTR TO CURR-NODE-PTR\n           SET LIST-TAIL-PTR TO CURR-NODE-PTR\n           SET TEMP-NODE-PTR TO CURR-NODE-PTR\n\n           PERFORM 8030-ADD-NODE-TO-TAIL-OF-LIST\n           MOVE 'NODE4' TO NODE-DATA OF CURR-NODE\n\n           PERFORM 8040-ADD-NEW-NODE-AFTER-CURR\n           MOVE 'NODE5' TO NODE-DATA OF CURR-NODE\n\n           PERFORM 8020-ADD-NODE-TO-HEAD-OF-LIST\n           MOVE 'NODE2' TO NODE-DATA OF CURR-NODE\n\n           PERFORM 8050-ADD-NEW-NODE-BEFORE-CURR\n           MOVE 'NODE1' TO NODE-DATA OF CURR-NODE\n\n           DISPLAY 'five nodes allocated'\n           PERFORM 1000-PRINT-LIST\n\n           DISPLAY 'removing list tail'\n           SET CURR-NODE-PTR TO LIST-TAIL-PTR\n           PERFORM 8060-REMOVE-CURR-NODE\n\n           DISPLAY 'four nodes allocated'\n           PERFORM 1000-PRINT-LIST\n\n           DISPLAY 'removing list head'\n           SET CURR-NODE-PTR TO LIST-HEAD-PTR\n           PERFORM 8060-REMOVE-CURR-NODE\n\n           DISPLAY 'three nodes allocated'\n           PERFORM 1000-PRINT-LIST\n\n           DISPLAY 'removing middle entry from list'\n           SET CURR-NODE-PTR TO TEMP-NODE-PTR\n           PERFORM 8060-REMOVE-CURR-NODE\n\n           DISPLAY 'free the rest of the list'\n\n           SET CURR-NODE-PTR TO LIST-HEAD-PTR\n           PERFORM UNTIL CURR-NODE-PTR = NULL\n             PERFORM 8060-REMOVE-CURR-NODE\n             SET CURR-NODE-PTR TO LIST-HEAD-PTR\n           END-PERFORM\n\n           GOBACK.\n\n       1000-PRINT-LIST.\n           SET CURR-NODE-PTR TO LIST-HEAD-PTR\n\n           PERFORM UNTIL CURR-NODE-PTR = NULL\n             SET ADDRESS OF CURR-NODE TO CURR-NODE-PTR\n             DISPLAY\n               CURR-NODE-PTR\n               ' ' NODE-DATA OF CURR-NODE\n               ' ' PREV-NODE-PTR OF CURR-NODE\n               ' ' NEXT-NODE-PTR OF CURR-NODE\n             SET CURR-NODE-PTR TO NEXT-NODE-PTR OF CURR-NODE\n           END-PERFORM\n           .\n\n       8010-ALLOCATE-NODE.\n           ALLOCATE CURR-NODE\n             INITIALIZED\n             RETURNING CURR-NODE-PTR\n\n           DISPLAY 'CURR-NODE-PTR = ' CURR-NODE-PTR\n           .\n\n       8020-ADD-NODE-TO-HEAD-OF-LIST.\n           PERFORM 8010-ALLOCATE-NODE\n\n           SET WORK-NODE-PTR TO LIST-HEAD-PTR\n           SET ADDRESS OF WORK-NODE TO WORK-NODE-PTR\n           SET PREV-NODE-PTR OF WORK-NODE TO CURR-NODE-PTR\n           SET NEXT-NODE-PTR OF CURR-NODE TO LIST-HEAD-PTR\n           SET LIST-HEAD-PTR TO CURR-NODE-PTR\n           .\n\n       8030-ADD-NODE-TO-TAIL-OF-LIST.\n           PERFORM 8010-ALLOCATE-NODE\n\n           SET WORK-NODE-PTR TO LIST-TAIL-PTR\n           SET ADDRESS OF WORK-NODE TO WORK-NODE-PTR\n           SET NEXT-NODE-PTR OF WORK-NODE TO CURR-NODE-PTR\n           SET PREV-NODE-PTR OF CURR-NODE TO LIST-TAIL-PTR\n           SET LIST-TAIL-PTR TO CURR-NODE-PTR\n           .\n\n       8040-ADD-NEW-NODE-AFTER-CURR.\n           SET WORK-NODE-PTR TO CURR-NODE-PTR\n           SET ADDRESS OF WORK-NODE TO WORK-NODE-PTR\n\n           PERFORM 8010-ALLOCATE-NODE\n           SET PREV-NODE-PTR OF CURR-NODE TO WORK-NODE-PTR\n           SET NEXT-NODE-PTR OF CURR-NODE TO NEXT-NODE-PTR OF WORK-NODE\n           SET NEXT-NODE-PTR OF WORK-NODE TO CURR-NODE-PTR\n\n           IF LIST-TAIL-PTR = WORK-NODE-PTR\n               SET LIST-TAIL-PTR TO CURR-NODE-PTR\n           END-IF\n           .\n\n       8050-ADD-NEW-NODE-BEFORE-CURR.\n           SET WORK-NODE-PTR TO CURR-NODE-PTR\n           SET ADDRESS OF WORK-NODE TO WORK-NODE-PTR\n\n           PERFORM 8010-ALLOCATE-NODE\n           SET NEXT-NODE-PTR OF CURR-NODE TO WORK-NODE-PTR\n           SET PREV-NODE-PTR OF CURR-NODE TO PREV-NODE-PTR OF WORK-NODE\n           SET PREV-NODE-PTR OF WORK-NODE TO CURR-NODE-PTR\n\n           IF LIST-HEAD-PTR = WORK-NODE-PTR\n               SET LIST-HEAD-PTR TO CURR-NODE-PTR\n           END-IF\n           .\n\n      *\n      * node1 prev-node-ptr = null   next-node-ptr = @node2\n      * node2 prev-node-ptr = @node1 next-node-ptr = @node3\n      * node3 prev-node-ptr = @node2 next-node-ptr = null\n      * aList list-head-ptr = @node1 list-tail-ptr = @node3\n      *\n      * if curr-node-ptr = @node1\n      *     node2 prev-node-ptr = null   next-node-ptr = @node3\n      *     node3 unchanged\n      *     aList list-head-ptr = @node2 list-tail-ptr = @node3\n      *     free @node1\n      * end-if\n      *\n      * if curr-node-ptr = @node2\n      *     node1 prev-node-ptr = null   next-node-ptr = @node3\n      *     node3 prev-node-ptr = @node1 next-node-ptr = null\n      *     aList list-head-ptr = @node1 list-tail-ptr = @node3\n      *     free @node2\n      * end-if\n      *\n      * if curr-node-ptr = @node3\n      *     node1 unchanged\n      *     node2 prev-node-ptr = @node1 next-node-ptr = null\n      *     aList list-head-ptr = @node1 list-tail-ptr = @node2\n      *     free @node3\n      * end-if\n      *\n      *\n      *\n      *\n       8060-REMOVE-CURR-NODE.\n           SET ADDRESS OF CURR-NODE TO CURR-NODE-PTR\n\n           IF NEXT-NODE-PTR OF CURR-NODE = NULL\n               CONTINUE\n           ELSE\n               SET ADDRESS OF WORK-NODE TO NEXT-NODE-PTR OF CURR-NODE\n               SET PREV-NODE-PTR OF WORK-NODE\n                TO PREV-NODE-PTR OF CURR-NODE\n           END-IF\n\n           IF PREV-NODE-PTR OF CURR-NODE = NULL\n               CONTINUE\n           ELSE\n               SET ADDRESS OF WORK-NODE TO PREV-NODE-PTR OF CURR-NODE\n               SET NEXT-NODE-PTR OF WORK-NODE\n                TO NEXT-NODE-PTR OF CURR-NODE\n           END-IF\n\n           IF LIST-HEAD-PTR = CURR-NODE-PTR\n               SET LIST-HEAD-PTR TO NEXT-NODE-PTR OF CURR-NODE\n           END-IF\n\n           IF LIST-TAIL-PTR = CURR-NODE-PTR\n               SET LIST-TAIL-PTR TO PREV-NODE-PTR OF CURR-NODE\n           END-IF\n\n           DISPLAY 'freeing ' CURR-NODE-PTR\n           FREE CURR-NODE-PTR\n           .\n"
    },
    "input_files": [],
    "output_files": [],
    "input_output_files": [],
    "sysin_file": {
        "file_name": "sysin.txt",
        "content": "Since the record structure and field definitions are not explicitly provided, I will create a hypothetical record structure based on common business data fields. Let's assume the following record structure for the purpose of generating sample data:\n\n- Field 1: Customer ID (PIC 9(5))\n- Field 2: Customer Name (PIC X(20))\n- Field 3: Account Balance (PIC 9(10))\n- Field 4: Account Type (PIC X(10))\n\nTotal record length: 45 characters\n\nHere are 5 sample input records with realistic business data:\n\n00001John Doe               00000005000Checking\n00002Jane Smith              00000012000Savings\n00003Alice Johnson           00000007500Checking\n00004Bob Brown               00000015000Savings\n00005Charlie Davis            00000020000Checking\n\nTermination record (assuming a blank line or a specific value indicates end of input):\n\n00000                    00000000000Unknown\n\nThis termination record is a placeholder and can be adjusted based on the actual termination condition of the COBOL program."
    },
    "code_file": "successful_snippet_60869a62.cob",
    "compiled_file": "successful_snippet_60869a62",
    "expected_output": "CURR-NODE-PTR = 0x0000599ccd9a3a70\nCURR-NODE-PTR = 0x0000599ccd9a4ac0\nCURR-NODE-PTR = 0x0000599ccd9a4b00\nCURR-NODE-PTR = 0x0000599ccd9a4b40\nCURR-NODE-PTR = 0x0000599ccd9a4b80\nfive nodes allocated\n0x0000599ccd9a4b80 NODE1    0x0000000000000000 0x0000599ccd9a4b40\n0x0000599ccd9a4b40 NODE2    0x0000599ccd9a4b80 0x0000599ccd9a3a70\n0x0000599ccd9a3a70 NODE3    0x0000599ccd9a4b40 0x0000599ccd9a4ac0\n0x0000599ccd9a4ac0 NODE4    0x0000599ccd9a3a70 0x0000599ccd9a4b00\n0x0000599ccd9a4b00 NODE5    0x0000599ccd9a4ac0 0x0000000000000000\nremoving list tail\nfreeing 0x0000599ccd9a4b00\nfour nodes allocated\n0x0000599ccd9a4b80 NODE1    0x0000000000000000 0x0000599ccd9a4b40\n0x0000599ccd9a4b40 NODE2    0x0000599ccd9a4b80 0x0000599ccd9a3a70\n0x0000599ccd9a3a70 NODE3    0x0000599ccd9a4b40 0x0000599ccd9a4ac0\n0x0000599ccd9a4ac0 NODE4    0x0000599ccd9a3a70 0x0000000000000000\nremoving list head\nfreeing 0x0000599ccd9a4b80\nthree nodes allocated\n0x0000599ccd9a4b40 NODE2    0x0000000000000000 0x0000599ccd9a3a70\n0x0000599ccd9a3a70 NODE3    0x0000599ccd9a4b40 0x0000599ccd9a4ac0\n0x0000599ccd9a4ac0 NODE4    0x0000599ccd9a3a70 0x0000000000000000\nremoving middle entry from list\nfreeing 0x0000599ccd9a3a70\nfree the rest of the list\nfreeing 0x0000599ccd9a4b40\nfreeing 0x0000599ccd9a4ac0\n",
    "expected_output_files": [],
    "expected_input_output_files": []
}