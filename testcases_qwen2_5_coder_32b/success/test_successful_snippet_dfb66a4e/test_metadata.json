{
    "cobol_file": {
        "file_name": "successful_snippet_dfb66a4e.cob",
        "content": "      ******************************************************************\n      * author: Erik Eriksen\n      * date: 2021-07-22\n      * updated: 2022-04-28\n      * purpose: Unstring field into another field examples.\n      * tectonics: cobc\n      ******************************************************************\n       identification division.\n       program-id. unstring-example.\n       data division.\n       file section.\n       working-storage section.\n\n       01  ws-source-str                  pic x(30).\n\n       01  ws-dest-str.\n           05  ws-part-1                  pic x(15).\n           05  ws-part-2                  pic x(15).\n\n\n       01  ws-delimiter                   pic x value '|'.\n\n       01  ws-single-stats.\n           05  ws-single-fields-filled    pic 99.\n           05  ws-single-dest-info.\n               10  ws-single-dest-str     pic x(5).\n               10  ws-single-delimiter    pic x.\n               10  ws-single-char-count   pic 9.\n\n       01  ws-multi-stats.\n           05  ws-multi-fields-filled     pic 99.\n           05  ws-multi-dest-info         occurs 6 times\n                                          indexed by ws-multi-idx.\n               10  ws-multi-dest-str      pic x(5).\n               10  ws-multi-delimiter     pic x.\n               10  ws-multi-char-count    pic 9.\n\n       01  ws-pointer                     pic 9(5) comp.\n\n       01  ws-source-num                  pic $999,999.99.\n       01  ws-dest-num                    pic 999 occurs 3 times.\n\n       procedure division.\n\n       main-procedure.\n\n           move \"Hello World\" to ws-source-str\n\n      *> EXAMPLE 1:\n      *> This is a simple example of unstringing a value into other\n      *> variables\n           display spaces\n           display \"=================================================\"\n           display \"EX 1 : SIMPLE UNSTRING\"\n           display space\n           display \"SOURCE STRING: \" ws-source-str\n\n           unstring ws-source-str\n               delimited by space\n               into ws-part-1 ws-part-2\n           end-unstring\n\n           display \"PART1: \" ws-part-1\n           display \"PART2: \" ws-part-2\n\n\n      *> EXAMPLE 2:\n      *> This is an example of unstringing a variable into another using\n      *> space as the delimter. The pointer is a running current string\n      *> position variable. At the start, it's set to one (start of string)\n      *> and then auto incremented by the unstring command each time it\n      *> is called. It's value is the position in the source string where\n      *> it \"left off\".\n           move 1 to ws-pointer\n\n           display spaces\n           display \"=================================================\"\n           display \"EX 2 : UNSTRING MULTIPLE TIMES INTO SAME DEST.\"\n\n      *> Overflow first time because pointer is not past end of source data\n      *> indicating that there was more source string to unstring that did\n      *> not fit in the destination (\"into\") variables.\n      *>\n      *> In example 3, we see that if UNSTRING is able to split the source\n      *> string into the destiniation variables, there is no overflow.\n\n           display space\n           display \"SOURCE STRING: \" ws-source-str\n\n           perform 2 times\n               unstring ws-source-str delimited by all spaces\n                   into ws-part-1\n                   with pointer ws-pointer\n                   on overflow\n                       display \"ERROR: OVERFLOW\"\n                   not on overflow\n                       display \"Successfully unstrung.\"\n               end-unstring\n\n               display \"PART VALUE: \" ws-part-1\n               display \"POINTER: \" ws-pointer\n           end-perform\n\n\n      *> EXAMPLE 3:\n      *> This is similar to example 1 but only requires one call to\n      *> unstring the whole source string due to there being enough\n      *> destination (into) variables supplied. The pointer isn't used\n      *> but is added to show that it's position is at the end of the\n      *> source string length after the unstring is performed.\n           display spaces\n           display \"=================================================\"\n           display \"EX 3 : UNSTRING INTO EXPLICIT FIELDS\"\n\n           move 1 to ws-pointer\n      *> No overflow because pointer is past end of source data length\n      *> by the end of the command scope.\n\n           display space\n           display \"SOURCE STRING: \" ws-source-str\n\n           unstring ws-source-str delimited by all spaces\n               into ws-part-1 ws-part-2\n               with pointer ws-pointer\n               on overflow\n                   display \"ERROR: OVERFLOW\"\n               not on overflow\n                   display \"Successfully unstrung.\"\n           end-unstring\n\n           display \"PART1: \" ws-part-1\n           display \"PART2: \" ws-part-2\n           display \"POINTER: \" ws-pointer\n\n\n      *> EXAMPLE 4:\n      *> This example uses a loop to unstring the source string into\n      *> a single variable. There are multiple delimiters specified that\n      *> split the string up. There are also some statistics/useful\n      *> info added by adding delmiter in, count in, and tallying in\n      *> keywords.\n           display spaces\n           display \"=================================================\"\n           display \"EX 4 : UNSTRING WITH MULTIPLE DELIMITERS \"\n\n           move 1 to ws-pointer\n\n           move \"A<B<CD>E%FG!HIJ|KL!MN>OP#QR!ST\" to ws-source-str\n\n           display space\n           display \"SOURCE STRING: \" ws-source-str\n\n           perform until ws-pointer > function length(ws-source-str)\n\n               unstring ws-source-str\n                   delimited by all \"<\" or \">\" or \"!\" or ws-delimiter\n                   into\n                       ws-single-dest-str\n                           delimiter in ws-single-delimiter\n                           count in ws-single-char-count\n                   with pointer ws-pointer\n                   tallying in ws-single-fields-filled\n               end-unstring\n\n               display space\n               display \"VALUE: \" ws-single-dest-str\n               display \"DELIMITER: \" ws-single-delimiter\n               display \"CHAR COUNT:\" ws-single-char-count\n               display \"CURRENT POINTER: \" ws-pointer\n               display \"TOTAL FIELDS FILLED: \" ws-single-fields-filled\n               display \"-------------------------------------------\"\n           end-perform\n\n      *> EXAMPLE 5:\n      *> This example is similar to example 4 except that the source\n      *> string is unstrung with multiple delimiters into multiple\n      *> destination strings.\n           display spaces\n           display \"=================================================\"\n           display \"EX 5 : UNSTRING WITH MULTIPLE DELIMITERS \" &\n               \"INTO MULTIPLE DESTINATIONS\"\n\n           move \"A<B<CD>EFG!HIJ|KLMN>O\" to ws-source-str\n\n           display space\n           display \"SOURCE STRING: \" ws-source-str\n\n           unstring ws-source-str\n               delimited by\n                   all \"<\"\n                   or all \">\"\n                   or \"!\"\n                   or ws-delimiter\n               into\n                   ws-multi-dest-str(1)\n                       delimiter in ws-multi-delimiter(1)\n                       count in ws-multi-char-count(1)\n                   ws-multi-dest-str(2)\n                       delimiter in ws-multi-delimiter(2)\n                       count in ws-multi-char-count(2)\n                   ws-multi-dest-str(3)\n                       delimiter in ws-multi-delimiter(3)\n                       count in ws-multi-char-count(3)\n                   ws-multi-dest-str(4)\n                       delimiter in ws-multi-delimiter(4)\n                       count in ws-multi-char-count(4)\n                   ws-multi-dest-str(5)\n                       delimiter in ws-multi-delimiter(5)\n                       count in ws-multi-char-count(5)\n                   ws-multi-dest-str(6)\n                       delimiter in ws-multi-delimiter(6)\n                       count in ws-multi-char-count(6)\n               tallying in ws-multi-fields-filled\n           end-unstring\n\n           perform varying ws-multi-idx\n           from 1 by 1 until ws-multi-idx > 6\n               display space\n               display \"STRING NUMBER: \" ws-multi-idx\n               display \"VALUE: \" ws-multi-dest-str(ws-multi-idx)\n               display \"DELIMITER: \" ws-multi-delimiter(ws-multi-idx)\n               display \"CHAR COUNT:\" ws-multi-char-count(ws-multi-idx)\n               display \"-------------------------------------------\"\n           end-perform\n\n           display \"TOTALS: \"\n           display \"FIELDS FILLED: \" ws-multi-fields-filled\n\n\n\n      *> EXAMPLE 6:\n      *> This examples using UNSTRING to get parts of a formatted\n      *> number. It's probably not the best example but gives an\n      *> idea.\n           display spaces\n           display \"=================================================\"\n           display \"EX 6 : UNSTRING FORMATTED NUMBER\"\n           display space\n\n           move 123456.12 to ws-source-num\n           display \"SOURCE VALUE: \" ws-source-num\n\n           unstring ws-source-num(2:) *> start at 2 to not include '$'\n               delimited by ',' or '.'\n               into ws-dest-num(1)\n                   ws-dest-num(2)\n                   ws-dest-num(3)\n           end-unstring\n\n           display \"PART 1: \" ws-dest-num(1)\n           display \"PART 2: \" ws-dest-num(2)\n           display \"PART 3: \" ws-dest-num(3)\n           display space\n\n           goback.\n\n       end program unstring-example.\n"
    },
    "input_files": [],
    "output_files": [],
    "input_output_files": [],
    "sysin_file": null,
    "code_file": "successful_snippet_dfb66a4e.cob",
    "compiled_file": "successful_snippet_dfb66a4e",
    "expected_output": " \n=================================================\nEX 1 : SIMPLE UNSTRING\n \nSOURCE STRING: Hello World                   \nPART1: Hello          \nPART2: World          \n \n=================================================\nEX 2 : UNSTRING MULTIPLE TIMES INTO SAME DEST.\n \nSOURCE STRING: Hello World                   \nERROR: OVERFLOW\nPART VALUE: Hello          \nPOINTER: 00007\nSuccessfully unstrung.\nPART VALUE: World          \nPOINTER: 00031\n \n=================================================\nEX 3 : UNSTRING INTO EXPLICIT FIELDS\n \nSOURCE STRING: Hello World                   \nSuccessfully unstrung.\nPART1: Hello          \nPART2: World          \nPOINTER: 00031\n \n=================================================\nEX 4 : UNSTRING WITH MULTIPLE DELIMITERS \n \nSOURCE STRING: A<B<CD>E%FG!HIJ|KL!MN>OP#QR!ST\n \nVALUE: A    \nDELIMITER: <\nCHAR COUNT:1\nCURRENT POINTER: 00003\nTOTAL FIELDS FILLED: 01\n-------------------------------------------\n \nVALUE: B    \nDELIMITER: <\nCHAR COUNT:1\nCURRENT POINTER: 00005\nTOTAL FIELDS FILLED: 02\n-------------------------------------------\n \nVALUE: CD   \nDELIMITER: >\nCHAR COUNT:2\nCURRENT POINTER: 00008\nTOTAL FIELDS FILLED: 03\n-------------------------------------------\n \nVALUE: E%FG \nDELIMITER: !\nCHAR COUNT:4\nCURRENT POINTER: 00013\nTOTAL FIELDS FILLED: 04\n-------------------------------------------\n \nVALUE: HIJ  \nDELIMITER: |\nCHAR COUNT:3\nCURRENT POINTER: 00017\nTOTAL FIELDS FILLED: 05\n-------------------------------------------\n \nVALUE: KL   \nDELIMITER: !\nCHAR COUNT:2\nCURRENT POINTER: 00020\nTOTAL FIELDS FILLED: 06\n-------------------------------------------\n \nVALUE: MN   \nDELIMITER: >\nCHAR COUNT:2\nCURRENT POINTER: 00023\nTOTAL FIELDS FILLED: 07\n-------------------------------------------\n \nVALUE: OP#QR\nDELIMITER: !\nCHAR COUNT:5\nCURRENT POINTER: 00029\nTOTAL FIELDS FILLED: 08\n-------------------------------------------\n \nVALUE: ST   \nDELIMITER:  \nCHAR COUNT:2\nCURRENT POINTER: 00031\nTOTAL FIELDS FILLED: 09\n-------------------------------------------\n \n=================================================\nEX 5 : UNSTRING WITH MULTIPLE DELIMITERS INTO MULTIPLE DESTINATIONS\n \nSOURCE STRING: A<B<CD>EFG!HIJ|KLMN>O         \n \nSTRING NUMBER: +000000001\nVALUE: A    \nDELIMITER: <\nCHAR COUNT:1\n-------------------------------------------\n \nSTRING NUMBER: +000000002\nVALUE: B    \nDELIMITER: <\nCHAR COUNT:1\n-------------------------------------------\n \nSTRING NUMBER: +000000003\nVALUE: CD   \nDELIMITER: >\nCHAR COUNT:2\n-------------------------------------------\n \nSTRING NUMBER: +000000004\nVALUE: EFG  \nDELIMITER: !\nCHAR COUNT:3\n-------------------------------------------\n \nSTRING NUMBER: +000000005\nVALUE: HIJ  \nDELIMITER: |\nCHAR COUNT:3\n-------------------------------------------\n \nSTRING NUMBER: +000000006\nVALUE: KLMN \nDELIMITER: >\nCHAR COUNT:4\n-------------------------------------------\nTOTALS: \nFIELDS FILLED: 06\n \n=================================================\nEX 6 : UNSTRING FORMATTED NUMBER\n \nSOURCE VALUE: $123,456.12\nPART 1: 123\nPART 2: 456\nPART 3: 012\n \n",
    "expected_output_files": [],
    "expected_input_output_files": []
}